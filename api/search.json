[{"id":"f372b3957c8592bc34d2e3ae020922e0","title":"二战小国","content":"引子第二次世界大战初期，德军提出了一种全新战术：利用机械化部队快速地穿插敌军防线，撕开缺口后步兵马上涌入，保护攻击矛头的侧翼，同时机械部队继续前进，深入敌军后方的重要目标，破坏敌方的指挥和后勤系统，分割包围敌军，使其无法造成有效的防御。这套战略在面对众多欧洲小国时十分有效，大部分国家没有组成任何有效的防御就宣告投降，尽管它们在战争中相对较弱，但它们的表现却在战争的进程中发挥了重要作用。\n波兰挪威丹麦","slug":"二战小国","date":"2024-10-16T00:54:54.000Z","categories_index":"","tags_index":"二战杂谈","author_index":"Math-zhuxy"},{"id":"3ffef40c161f2bcfcf068173b0dcabaa","title":"斯大林格勒战役","content":"引子斯大林格勒战役无疑是二战中最出名的战役，它不仅粉碎了德军企图控制苏联高加速地区巴库油田的计划，使得德国的装甲部队因为油量不够不得不转入战略防御。\n介绍战役之前1942年以前，小胡子一直处于春风得意的状态。在西线，一战磕了四年的死对头“法国”被曼施坦因的装甲部队直接撕碎，仅仅坚持了39天就投降，其他一北欧小国如丹麦和挪威也纷纷投降；在东线，巴巴罗萨计划前期的进展极其顺利，德军在仅伤亡了十几万人的情况下，歼灭的苏军数百万的军队，成建制的苏军被德军击溃，俘虏。在明斯克-比亚韦斯托克战役（1941年6月22日 - 7月9日）、乌曼战役（1941年7月15日 - 8月8日）、基辅战役（1941年8月23日 - 9月26日）、维亚济马-布良斯克战役（1941年10月2日 - 10月13日）和哈尔科夫战役（1942年5月12日 - 5月28日）中德军一共俘虏了约200万苏军部队，德国前线局势大好。\n蓝色计划到了1942年3月底，情况出现了变化，最重要的就是德军的储油量不够了，机械化部队的移动都需要燃料，没有燃料就只能变成动不了的铁疙瘩，而德军的产油主要靠罗马尼亚的普洛耶什蒂油田和工业合成。因此，德国总参谋部提供了代号为蓝色计划的方案。具体来说，蓝色方案主要有三个目标：\n\n进攻苏联南部，占领高加索油田，特别是巴库油田\n控制伏尔加河流域，切断苏联的资源供给\n推进到苏联边境，阻止英美盟军向苏联提供物资援助，尤其是来自波斯的援助线路。\n\n整个蓝色计算的执行比较复杂，总共可以分为四个阶段：\n\n蓝色一号，从库尔斯克出发，直接抵达沃罗涅日\n蓝色二号，第一路从沃罗涅日出发向南，第二路从哈尔科夫出发向东，两路人马在米列罗沃汇合\n蓝色三号，第一路从米列罗沃出发向东穿过顿河，第二路从南边经过罗斯托夫，一路向东，两路人马在斯大林格勒门口会师。\n蓝色四号，全面进入高加索地区\n\n\n没必要的战斗在蓝色计划最初的方案中，完全没有斯大林格勒什么事，最多也就是在斯大林格勒郊区，然后炮火压制，干扰伏尔加河的物流。德国的参谋团队也不是吃素的，早就研究过这里不是特别好打的，这个城市背靠伏尔加河，所以它无论什么时候都是有补给的，德军很难完全地包围它。而且，整个蓝色方案分为了A集团军群和B集团军群。B集团军群负责沃罗涅日-斯大林格勒这条战线，主要作用是保护A集团军群的侧翼；而A集团军群才是主力，负责高加索地区，他们需要依次攻占科迈普油田、格罗兹尼油田、巴库油田。简化一下就是：在蓝色计划中，保卢斯所在第六集团军群的B集团军群只是起到了辅助的作用，结果最后却演变为B集团军群冲到城里和苏军血战，完全违背了蓝色计划的初衷。不少人认为斯大林格勒很重要，反复强调所谓的兵家必争之地。斯大林格勒背靠伏尔加河，现代化工厂林立，确实很重要。但苏联的重要城市很多，玩过钢4的都知道，苏联的胜利点很多，很多都在远东地区，一个个踩很费力，没办法很快瓦解。（大部分都是靠内奸渗透瓦解国家政治体系）就算莫斯科、列宁格勒、斯大林格勒全部失守，只要苏军沿着南北流向的河流纵深防御，同样能拦截德军的进攻。因此，斯大林格勒值得一试，但时候需要重兵血战，还值得商榷。\n蓝色计划初期蓝色计划初期进展的极为顺利，德军一路猛攻，\n","slug":"斯大林格勒战役","date":"2024-10-15T10:23:42.000Z","categories_index":"","tags_index":"二战杂谈","author_index":"Math-zhuxy"},{"id":"9e3f215a3ac1a80702d532ae53dd204a","title":"法国战役","content":"引子二战时期的法国战役一直是人们“辱法”的最常用的例子。法国在二战中仅“坚持”了39天就投降，甚至不如苏德战场中斯大林格勒战役的一栋楼的守卫时间，\n","slug":"法国战役","date":"2024-10-15T10:19:13.000Z","categories_index":"","tags_index":"二战杂谈","author_index":"Math-zhuxy"},{"id":"25ed3aa3446c2c64cf6228f9f4e4f9c4","title":"DP","content":"简介DP是一个非常广泛的题目类型。比较难的DP题目一般都很抽象，很难提取出DP数组出来，这边文章也只是笼统的介绍一下DP，并介绍一个DP最经典最简单的例子。\n","slug":"DP","date":"2024-10-15T10:12:39.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"53896b079468d4c41963b2300dea196e","title":"KMP","content":"KMP简介假设有两个字符串需要匹配，此时已经匹配到i，j位置：母串：str1 … str1 a(i) …字串：str1 (j’) … str1 b(j) …\n发现index位置a与b不相等，此时字串的匹配指针j不需要重新移到开始，i指针也不需要移动，j指针只要移动到j’位置即可\n因此我们只需要找到最长前后缀即可：以str&#x3D;”abcdefabc”为例\n注意：为了方便表示，我们让字符串下标从1开始\nne数组Next[i]&#x3D;j表示:str[1,j]&#x3D;str[i-j+1,i]以下图为例：Next[i]的方法：对于母串STR和字串str，假如母串从xi-1 ,子串从1j都是匹配的，此时匹配下一个位置：如果STR[i]&#x3D;&#x3D;str[j+1]，则i和j继续向后移动一位如果STR[i]!&#x3D;str[j+1]:注意到对于str来说，1到Next[j]段等于…到j段，而子串和母串的STR[…,i-1]与str[1,j]是相等的同时，根据Next数组定义：str[1,Next[j]]与str[…,j]是相等的，因此：STR[…,i-1]与str[1,Next[j]]部分是相等的，因此j指针可以移动到Next[j]，让i与Next[j]+1匹配因此i指针不用动，j指针可以退回到Next[j]以下图为例：匹配过程的代码：\n12345678//i从1开始遍历母串所有的字符，j从0开始(因为STR[i]与str[j+1]匹配的)for(int i = 1, j = 0; i &lt;= m; i ++)&#123;    //如果s[i]与s[j+1]不匹配，一直移动到无前后缀相等或者匹配为止    while(j &amp;&amp; s[i] != s[j+1])j=Next[j];    //如果是匹配成功的情况，j和i可以往下一位走了    if(s[i] == s[j+1])j++;    if(j == n)printf(&quot;ok&quot;);//已经移动到子串的末尾了，匹配成功&#125;\n接下来即是如何求解Next[i]:Next[i]的求解过程其实和字符串的匹配过程很相似首先Next[1]&#x3D;0，第一个字母匹配失败了，只能从0开始了。对于每个i假如str[i]与str[j+1]不匹配，即前后缀不等，那么j往前移动到Next[j]处继续匹配。其实就是自己和自己匹配的过程：\n123456for(int i = 2, j = 0; i &lt;= m; i ++)&#123;    while(j &amp;&amp; s[i] != s[j+1])j=Next[j];    if(s[i] == s[j+1])j++;    //将最后的结果存入Next[i]中    Next[i]=j;&#125;\n题目及解答给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉数字。\n模式串 P在字符串 S中多次作为子串出现。\n求出模式串 P在字符串 S中所有出现的位置的起始下标。代码：\n12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int n, m;const int N = 100010, M = 1000010;char p[N], s[M];int ne[N];int main() &#123;\tcin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;\tfor (int i = 2, j = 0; i &lt;= n; i++) &#123;\t\twhile (j &amp;&amp; p[i] != p[j + 1])j = ne[j];\t\tif (p[i] == p[j + 1])j++;\t\tne[i] = j;\t&#125;\tfor (int i = 1, j = 0; i &lt;= m; i++) &#123;\t\twhile (j &amp;&amp; s[i] != p[j + 1])j = ne[j];\t\tif (s[i] == p[j + 1])j++;\t\tif (j == n)&#123;\t\t    printf(&quot;%d &quot;, i - n);\t\t    j=ne[j];\t\t&#125;\t&#125;&#125;\n优化其实next数组还是可以进一步优化，举个例子：假设字符a的下标为i，其next值为next[i]，假设str[i]&#x3D;&#x3D;str[next[i]]，则不妨发现：当str在j+1处的与STR不的i处匹配，则str的j将跳到next[j]处，但此时next[j]与j处是相等的，因此这个匹配其实是没有必要的，可以直接移到next[next[i]]处，如此循环。我们用nextval数组储存这个最终的移动结果，表示：如果j处不匹配，则直接移动到nextval[j]处。求nextval方法：\n123456for(int i=1;i&lt;=n;i++)&#123;\t//如果相等，直接移动到next[i]的nextval处。\tif(str[i]==str[next[i]])nextval[i]=nextval[next[i]];\t//如果不相等，不需要多次移\telse nextval[i]=next[i];&#125;","slug":"KMP","date":"2024-10-14T02:54:06.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"cdfc7cbbb7cbed062094116ffd80f917","title":"DFS","content":"DFS简介DFS属于一种树的遍历方式。基本框架如下：\n1234567891011121314151617#include&lt;iostream&gt;using namespace stdvoid dfs(Node a)&#123;    if(a==NULL)return;    //标记该节点为已用    a.used=true;    //a节点处理    if(check(a))&#123;        printf(&quot;get answer&quot;);        return;    &#125;    //遍历该节点的其他相邻节点    dfs(a.next_1);    dfs(a.next_2);    //...    //回溯，标记该节点为未用状态    a.used=false;\n为什么要回溯以上面的代码为例，如果代码已经运行到a.used=false;这一行，代表前面的dfs(a.next_1);dfs(a.next_2);都没有找到结果，证明走到a节点其实是找不到结果的，因此需要回退会a节点的父节点继续寻找，此时要标记a节点为为使用状态。\nDFS遍历顺序假设有一棵树结构如下：以上面的代码为例，假设L点满足我们的要求遍历路径如下：A-&gt;B-&gt;E-&gt;J-&gt;回溯(E)-&gt;回溯(B)-&gt;B-&gt;F-&gt;回溯(A)-&gt;C-&gt;G-&gt;K-&gt;回溯(G)-&gt;G-&gt;L-&gt;符合答案，输出下面给出几道常见的DFS题目：\nN皇后问题皇后问题是指将 n个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。现在给定整数N ，请你输出所有的满足条件的棋子摆法。代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;bool Arr[20][20];int n;int DirX[4]=&#123;1,1,-1,-1&#125;;int DirY[4]=&#123;1,-1,1,-1&#125;;bool IsOk(int x,int y)&#123;    for(int i=1;i&lt;=n;i++)&#123;        if(Arr[i][y])return false;    &#125;    int k,q;    for(int i=0;i&lt;4;i++)&#123;        k=x;        q=y;        while(k&gt;=1&amp;&amp;k&lt;=n&amp;&amp;q&gt;=1&amp;&amp;q&lt;=n)&#123;            if(Arr[k][q])return false;            k+=DirX[i];            q+=DirY[i];        &#125;    &#125;    return true;&#125;void dfs(int num)&#123;    if(num&gt;n)&#123;        for(int i=1;i&lt;num;i++)&#123;            for(int j=1;j&lt;num;j++)&#123;                if(Arr[i][j])printf(&quot;Q&quot;);                else printf(&quot;.&quot;);            &#125;            printf(&quot;\\n&quot;);        &#125;        printf(&quot;\\n&quot;);        return;    &#125;    for(int j=1;j&lt;=n;j++)&#123;        if(IsOk(num,j))&#123;            Arr[num][j]=true;            dfs(num+1);            Arr[num][j]=false;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    dfs(1);&#125;\n","slug":"DFS","date":"2024-10-12T04:56:45.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"07311a8ec5a05f13261d3a44658af323","title":"欢迎","content":"网站简介这是我自己做的一个博客网站。博客框架是hexo，用来github提供的域名。目前没想好写什么东西，大概会写一些算法教程之类的东西。\n","slug":"welcome","date":"2024-10-12T03:00:46.000Z","categories_index":"","tags_index":"网站简介","author_index":"Math-zhuxy"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-10-12T02:36:20.905Z","categories_index":"","tags_index":"","author_index":"Math-zhuxy"}]