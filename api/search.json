[{"id":"53896b079468d4c41963b2300dea196e","title":"KMP","content":"KMP简介假设有两个字符串需要匹配，此时已经匹配到i，j位置：母串：str1 … str1 a(i) …字串：str1 (j’) … str1 b(j) …\n发现index位置a与b不相等，此时字串的匹配指针j不需要重新移到开始，i指针也不需要移动，j指针只要移动到j’位置即可\n因此我们只需要找到最长前后缀即可：以str&#x3D;”abcdefabc”为例\n注意：为了方便表示，我们让字符串下标从1开始\nne数组Next[i]&#x3D;j表示:str[1,j]&#x3D;str[i-j+1,i]以下图为例：Next[i]的方法：对于母串STR和字串str，假如母串从xi-1 ,子串从1j都是匹配的，此时匹配下一个位置：如果STR[i]&#x3D;&#x3D;str[j+1]，则i和j继续向后移动一位如果STR[i]!&#x3D;str[j+1]:注意到对于str来说，1到Next[j]段等于…到j段，而子串和母串的STR[…,i-1]与str[1,j]是相等的同时，根据Next数组定义：str[1,Next[j]]与str[…,j]是相等的，因此：STR[…,i-1]与str[1,Next[j]]部分是相等的，因此j指针可以移动到Next[j]，让i与Next[j]+1匹配因此i指针不用动，j指针可以退回到Next[j]以下图为例：匹配过程的代码：\n12345678//i从1开始遍历母串所有的字符，j从0开始(因为STR[i]与str[j+1]匹配的)for(int i = 1, j = 0; i &lt;= m; i ++)&#123;    //如果s[i]与s[j+1]不匹配，一直移动到无前后缀相等或者匹配为止    while(j &amp;&amp; s[i] != s[j+1])j=Next[j];    //如果是匹配成功的情况，j和i可以往下一位走了    if(s[i] == s[j+1])j++;    if(j == n)printf(&quot;ok&quot;);//已经移动到子串的末尾了，匹配成功&#125;\n接下来即是如何求解Next[i]:Next[i]的求解过程其实和字符串的匹配过程很相似首先Next[1]&#x3D;0，第一个字母匹配失败了，只能从0开始了。对于每个i假如str[i]与str[j+1]不匹配，即前后缀不等，那么j往前移动到Next[j]处继续匹配。其实就是自己和自己匹配的过程：\n123456for(int i = 2, j = 0; i &lt;= m; i ++)&#123;    while(j &amp;&amp; s[i] != s[j+1])j=Next[j];    if(s[i] == s[j+1])j++;    //将最后的结果存入Next[i]中    Next[i]=j;&#125;\n题目及解答给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉数字。\n模式串 P在字符串 S中多次作为子串出现。\n求出模式串 P在字符串 S中所有出现的位置的起始下标。代码：\n12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int n, m;const int N = 100010, M = 1000010;char p[N], s[M];int ne[N];int main() &#123;\tcin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;\tfor (int i = 2, j = 0; i &lt;= n; i++) &#123;\t\twhile (j &amp;&amp; p[i] != p[j + 1])j = ne[j];\t\tif (p[i] == p[j + 1])j++;\t\tne[i] = j;\t&#125;\tfor (int i = 1, j = 0; i &lt;= m; i++) &#123;\t\twhile (j &amp;&amp; s[i] != p[j + 1])j = ne[j];\t\tif (s[i] == p[j + 1])j++;\t\tif (j == n)&#123;\t\t    printf(&quot;%d &quot;, i - n);\t\t    j=ne[j];\t\t&#125;\t&#125;&#125;","slug":"KMP","date":"2024-10-14T02:54:06.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"cdfc7cbbb7cbed062094116ffd80f917","title":"DFS","content":"DFS简介DFS属于一种树的遍历方式。基本框架如下：\n1234567891011121314151617#include&lt;iostream&gt;using namespace stdvoid dfs(Node a)&#123;    if(a==NULL)return;    //标记该节点为已用    a.used=true;    //a节点处理    if(check(a))&#123;        printf(&quot;get answer&quot;);        return;    &#125;    //遍历该节点的其他相邻节点    dfs(a.next_1);    dfs(a.next_2);    //...    //回溯，标记该节点为未用状态    a.used=false;\n为什么要回溯以上面的代码为例，如果代码已经运行到a.used=false;这一行，代表前面的dfs(a.next_1);dfs(a.next_2);都没有找到结果，证明走到a节点其实是找不到结果的，因此需要回退会a节点的父节点继续寻找，此时要标记a节点为为使用状态。\nDFS遍历顺序假设有一棵树结构如下：以上面的代码为例，假设L点满足我们的要求遍历路径如下：A-&gt;B-&gt;E-&gt;J-&gt;回溯(E)-&gt;回溯(B)-&gt;B-&gt;F-&gt;回溯(A)-&gt;C-&gt;G-&gt;K-&gt;回溯(G)-&gt;G-&gt;L-&gt;符合答案，输出下面给出几道常见的DFS题目：\nN皇后问题皇后问题是指将 n个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。现在给定整数N ，请你输出所有的满足条件的棋子摆法。代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;bool Arr[20][20];int n;int DirX[4]=&#123;1,1,-1,-1&#125;;int DirY[4]=&#123;1,-1,1,-1&#125;;bool IsOk(int x,int y)&#123;    for(int i=1;i&lt;=n;i++)&#123;        if(Arr[i][y])return false;    &#125;    int k,q;    for(int i=0;i&lt;4;i++)&#123;        k=x;        q=y;        while(k&gt;=1&amp;&amp;k&lt;=n&amp;&amp;q&gt;=1&amp;&amp;q&lt;=n)&#123;            if(Arr[k][q])return false;            k+=DirX[i];            q+=DirY[i];        &#125;    &#125;    return true;&#125;void dfs(int num)&#123;    if(num&gt;n)&#123;        for(int i=1;i&lt;num;i++)&#123;            for(int j=1;j&lt;num;j++)&#123;                if(Arr[i][j])printf(&quot;Q&quot;);                else printf(&quot;.&quot;);            &#125;            printf(&quot;\\n&quot;);        &#125;        printf(&quot;\\n&quot;);        return;    &#125;    for(int j=1;j&lt;=n;j++)&#123;        if(IsOk(num,j))&#123;            Arr[num][j]=true;            dfs(num+1);            Arr[num][j]=false;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    dfs(1);&#125;\n","slug":"DFS","date":"2024-10-12T04:56:45.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"07311a8ec5a05f13261d3a44658af323","title":"欢迎","content":"网站简介这是我自己做的一个博客网站。博客框架是hexo，用来github提供的域名。目前没想好写什么东西，大概会写一些算法教程之类的东西。\n","slug":"welcome","date":"2024-10-12T03:00:46.000Z","categories_index":"","tags_index":"网站简介","author_index":"Math-zhuxy"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-10-12T02:36:20.905Z","categories_index":"","tags_index":"","author_index":"Math-zhuxy"}]