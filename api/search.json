[{"id":"1150f8d04ea2174e83f737731d4cd296","title":"PowerInfer论文","content":"论文核心内容\n目标解决在消费级GPU上高效运行大语言模型（LLM）的问题，特别是模型的高显存需求对现有硬件的限制。\n核心思想利用LLM推理过程中神经元激活的稀疏性和局部性，通过GPU-CPU混合推理引擎将经常活跃的神经元（热神经元）预加载到GPU上，而较少活跃的神经元（冷神经元）则由CPU计算，从而减小显存压力并优化数据传输。\n技术亮点\n\n\n局部性利用： LLM中的神经元激活具有幂律分布，少量热神经元贡献了大部分计算量。\n稀疏推理： 通过设计自适应预测器和神经元感知的稀疏运算算子，只对被预测为激活的神经元进行计算。\n优化数据分配： 提出了一种离线策略生成器，用于根据神经元的重要性和硬件特性决定其分配到GPU或CPU。\n\n技术细节架构设计离线阶段：\n神经元划分：\n使用通用数据集（如C4、Wikipedia）对模型进行分析，统计每个神经元的激活频率。\n将激活频率高的神经元标记为热神经元，频率低的标记为冷神经元。\n热神经元预加载到GPU，而冷神经元留在CPU上，减少了GPU显存需求。\n\n\n稀疏预测器的训练：\n利用离线分析数据，训练一个在线预测器，用于推理过程中动态预测当前输入将激活的神经元。\n\n\n\n在线阶段：\n动态预测神经元激活：\n对每一层的神经元，稀疏推理引擎通过预测器判断哪些神经元可能被激活。\n仅计算被预测为激活的神经元，跳过非激活神经元，显著减少计算量。\n\n\n分布式处理：\nGPU负责计算热神经元，这些神经元频繁被激活，对推理结果影响大。\nCPU负责处理冷神经元，这些神经元较少被激活，避免GPU资源浪费。\n\n\nGPU-CPU协同工作：\nGPU和CPU同时运行各自的神经元计算，结果通过优化的同步操作整合。\n\n\n\n关键模块：\n神经元预测器：动态预测哪些神经元会在当前输入下被激活，避免计算冗余。\n稀疏算子：基于神经元的矢量运算优化了传统稀疏矩阵运算。\nGPU-CPU协同处理：为每个推理任务分配独立线程，实现并行推理。\n\n具体实现离线阶段：如何分析热&#x2F;冷神经元\n数据集选择与输入生成：使用通用数据集（如C4和Wikipedia）生成大规模输入序列，这些数据具有广泛的代表性，用于模拟模型在真实场景下的推理行为。\n激活监控：在Transformer每一层的各个块（如MLP块或自注意力块）后插入监控内核（monitoring kernel），动态记录每次推理中每个神经元的激活状态。\n统计激活频率：\n\n\n神经元的激活由激活函数（如ReLU或SwiGLU）决定，当某个神经元的输出值不为零时，视为激活。\n通过多次推理，统计每个神经元的激活频率。\n\n\n热&#x2F;冷神经元划分标准：\n\n\n基于统计结果，观察神经元的激活遵循幂律分布：少量神经元的激活频率高，这些神经元被标记为热神经元。  \n其余神经元（大部分激活频率较低）被标记为冷神经元。\n\n\n热神经元的一致性分析：\n\n\n为验证热神经元是否稳定地在不同任务和输入中保持高激活频率，论文进一步通过多个任务（如知识问答、逻辑推理）的测试，发现热神经元在不同场景下激活的重叠度超过90%，证明这些神经元具有任务无关的稳定性。\n\n在线阶段：稀疏算子优化\n神经元感知的稀疏算子（Neuron-aware Sparse Operators）：\n\n\n在推理过程中，矩阵运算通常涉及大量零值，直接跳过这些零值运算可以减少不必要的计算。\n论文提出了一种神经元感知稀疏算子，专门优化矩阵-向量运算：\nGPU稀疏算子： 每个线程块处理一个神经元集合，独立检查是否激活并计算，避免了对稀疏矩阵的格式转换。\nCPU稀疏算子： 利用CPU的矢量扩展指令（如AVX2）对小批量激活神经元进行并行计算。\n\n\n\n\n稀疏推理流程的优化：\n\n\n预测器优化：\n根据每层的激活稀疏性和偏斜性调整预测器大小，确保高预测精度的同时降低GPU内存占用。\n\n\n计算图优化：\n构建基于稀疏性和依赖关系的计算图（DAG），在推理时动态调度计算任务。\n\n\n同步与结果合并：\nGPU和CPU分别计算后，通过高效的稀疏结果合并操作，将结果汇总到GPU。\n\n\n\n在线阶段：同步操作计算任务分离与并行化：\n\n热神经元与冷神经元的分离计算：GPU和CPU各自独立计算属于自己负责的神经元（GPU负责热神经元，CPU负责冷神经元），在计算过程中无需频繁通信，从而减少PCIe数据传输开销。\n独立线程管理：使用线程池并行化GPU和CPU上的神经元计算任务，尽量充分利用两种处理器的资源，避免同步时的阻塞。依赖管理与计算调度\n构建一个计算任务的有向无环图（DAG），每个计算任务（如矩阵乘法、激活函数运算）作为图中的节点。\n任务依赖检查：\n在同步操作前，通过依赖检查确认所有GPU任务或CPU任务的前置计算是否已完成。\n避免未完成任务导致的阻塞或错误结果。\n\n\n任务优先级分配：优先处理对后续任务有直接依赖的神经元，以减少同步等待。结果合并（Reduce操作）\nGPU主导合并：\n合并操作始终在GPU上进行，因为GPU更擅长处理大规模并行计算。\nCPU计算的冷神经元结果通过PCIe传输到GPU，并与GPU自身计算的热神经元结果一起完成最终的整合。\n\n\n稀疏合并优化：\n只传输和合并实际被激活的神经元结果，跳过未激活神经元对应的零值，进一步减少通信量和计算量。异步通信与重叠计算\n\n\n异步数据传输：\n使用CUDA异步API（如cudaMemcpyAsync）在CPU完成冷神经元计算后立即开始传输数据到GPU，同时GPU继续处理其他任务，充分利用传输和计算的时间重叠。\n\n\n动态任务平衡：如果CPU完成任务速度较慢，GPU可以动态调整其负载，帮助处理部分冷神经元任务。同步点优化（Barrier）\nGPU与CPU在每层神经元计算结束后只进行一次结果同步，而不是在每一步操作后同步。\n最小化同步次数：通过提前规划任务依赖和合并逻辑，确保同步点尽量少，且只在必要时触发。\n\n","slug":"powerinfer论文","date":"2024-11-19T12:30:31.000Z","categories_index":"","tags_index":"论文阅读","author_index":"Math-zhuxy"},{"id":"a8b6b9bbf4052440f27a448efb8e5b47","title":"配置极光主题","content":"下载HEXO首先要先下载npm，在Node.js官网下载LTS版本到本地。下载好后，在命令行中输入：\n1npm -v\n来查看版本如果之前已经下载过了，但是版本落后，可以输入\n1npm install npm@latest -g\n来更新至最新版本接下来安装HEXO框架，输入：\n1npm install -g hexo-cli\n常见命令如下：查看版本\n1hexo -v\n创建一个项目 hexo-blog 并初始化\n123hexo init hexo-blogcd hexo-blognpm install\n本地启动\n123hexo cleanhexo ghexo server\n极光主题在控制台中，进入 Hexo 项目的根目录，然后运行以下命令安装主题\n1npm install hexo-theme-aurora hexo-plugin-aurora --save\n因为主题是使用 NPM 或者 Yarn 安装的，而不是 clone 到 themes 文件夹的。所以我们需要自己创建一个配置文件。因此需要在 Hexo 博客的根目录下创建一个 _config.aurora.yml 配置文件来配置主题。打开在 Hexo 根目录下的 _config.yml，把 theme 的值改为 aurora\n1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: aurora\n因为使用了 Vue-router，Hexo 默认生成的页面和文章的 permalink 与我们 Vue router 中的 path 是不相符的，那么就会出现无法访问的问题，所以我们需要修改 Hexo 默认配置文件里面的 permalink 参数。修改后结果如下：\n12345678# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://tridiamond.techpermalink: /post/:title.htmlpermalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks\n\nGit talkgit talk配置相关属性说明：\n\nenable：使用true开启, 使用false关闭\nautoExpand：如果设置为true, Github 评论将会自动展开。否者默认会收起。\nclientID：clientID 是你 GitHub 的 Oauth APP 中提供的。\nclientSecret：clientSecret 是你 GitHub 的 Oauth APP 中提供的。\nrepo：仓库名\nowner：仓库拥有者的用户名\nadmin：仓库管理员的用户名，这里可以填写多个管理员。(也用于标记那个评论是博主的)\nid：确保唯一性和长度小于 50，如果您使用pathname，请确保长度小于 50 个字符或使用uid代替，这个有更好的兼容性 (如果您之前使用其他主题，谁用 uid 将可能无法显示您之前的评论)\nlanguage：使用 en 设置为英文，使用 cn 设置为中文.\ndistractionFreeMode：与 Facebook 一样的专注模式，点击评论输入框时会让背景变暗。true 来开启 false 来关闭\nrecentComment：是否开启最近评论功能。\nproxy：GitHub 授权请求的反向代理\n\n由于Gitalk配置proxy的默认地址被墙了，导致无法登录，因此需要手动写一个后台接口，注意谷歌浏览器的CORS协议：\n12345678910111213141516171819202122232425262728import requestsimport flaskfrom flask_cors import CORSserver = flask.Flask(__name__)CORS(server, resources=r&#x27;/*&#x27;)client_id = &quot;你自己的&quot;client_secret = &quot;你自己的&quot;@server.post(&#x27;/get_access_token&#x27;)def get_access_token():    url = &#x27;https://github.com/login/oauth/access_token&#x27;    params = &#123;        &#x27;client_id&#x27;: client_id,        &#x27;client_secret&#x27;: client_secret,        &#x27;code&#x27;: flask.request.json[&#x27;code&#x27;]    &#125;    headers = &#123;        &#x27;accept&#x27;: &#x27;application/json&#x27;    &#125;    result = requests.post(url=url, params=params, headers=headers, verify=False)    return result.json()if __name__ == &#x27;__main__&#x27;:    server.run(host=&#x27;0.0.0.0&#x27;, port=8011, debug=False)\n","slug":"极光主题配置","date":"2024-11-17T14:44:01.000Z","categories_index":"","tags_index":"配置","author_index":"Math-zhuxy"},{"id":"fa96493f1be9ea4e62c8ce720d007a3f","title":"哈夫曼树","content":"基本概念\n路径:从树中一个结点到另一个结点之间的分支构成这两个结点间的路径。\n\n结点的路径长度:两结点间路径上的分支数。\n\n树的路径长度：从树根到每一个结点的路径长度之和。\n\n权(又称权重)：将树中结点赋给一个有着某种含义的数值，(具体的意义根据树使用的场合确定)则这个数值称为该结点的权。\n\n结点的带权路径长度：从根结点到该结点之间的路径长度与结点上权的乘积\n\n树的带权路径长度:树中所有叶子结点的带权路径长度之和。\n\n树的路径长度:从树根到每一个结点的路径长度之和。\n\n“带权路径长度最短”是在“度相同”的树中比较而得的结果,因此有最优二叉树、最优三叉树之称。\n\n\n哈夫曼树定义:最优二叉树，带权路径长度(WPL)最短的二叉树，因为构造这种树的算法是由哈夫曼教授于1952年提出的,所以被称为哈夫曼树,相应的算法称为哈夫曼算法。\n哈夫曼树构造算法哈夫曼算法(1)根据n个给定的权值$(W_1,W_2,…, W_n)$构成$n$棵二叉树的森林$F&#x3D;(T_1, T_2,.., T_n)$,其中T_i只有一个带权为W_i的根结点。\n(2)在$F$中选取两棵根结点的权值最小的树作为左右子树,构造一棵新的二叉树,且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。\n(3)在$F$中删除这两棵树,同时将新得到的二叉树加入森林中。\n(4)重复(2)和(3),直到森林中只有一棵树为止,这棵树即为哈夫曼树。\n哈夫曼算法代码实现哈弗曼树中结点结构构建哈夫曼树时，首先需要确定树中结点的构成。由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。\n12345//哈夫曼树结点结构typedef struct &#123;    int weight;//结点权重    int parent, left, right;//父结点、左孩子、右孩子在数组中的位置下标&#125;HTNode, *HuffmanTree;\n哈弗曼树中的查找算法构建哈夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。\n查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：\n如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；如果介于两个结点权重值之间，替换原来较大的结点；\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//HT数组中存放的哈夫曼树，end表示HT数组中存放结点的最终位置，s1和s2传递的是HT数组中权重值最小的两个结点在数组中的位置void Select(HuffmanTree HT, int end, int *s1, int *s2)&#123;    int min1, min2;    //遍历数组初始下标为 1    int i = 1;    //找到还没构建树的结点    while(HT[i].parent != 0 &amp;&amp; i &lt;= end)&#123;        i++;    &#125;    min1 = HT[i].weight;    *s1 = i;       i++;    while(HT[i].parent != 0 &amp;&amp; i &lt;= end)&#123;        i++;    &#125;    //对找到的两个结点比较大小，min2为大的，min1为小的    if(HT[i].weight &lt; min1)&#123;        min2 = min1;        *s2 = *s1;        min1 = HT[i].weight;        *s1 = i;    &#125;else&#123;        min2 = HT[i].weight;        *s2 = i;    &#125;    //两个结点和后续的所有未构建成树的结点做比较    for(int j=i+1; j &lt;= end; j++)    &#123;        //如果有父结点，直接跳过，进行下一个        if(HT[j].parent != 0)&#123;            continue;        &#125;        //如果比最小的还小，将min2=min1，min1赋值新的结点的下标        if(HT[j].weight &lt; min1)&#123;            min2 = min1;            min1 = HT[j].weight;            *s2 = *s1;            *s1 = j;        &#125;        //如果介于两者之间，min2赋值为新的结点的位置下标        else if(HT[j].weight &gt;= min1 &amp;&amp; HT[j].weight &lt; min2)&#123;            min2 = HT[j].weight;            *s2 = j;        &#125;    &#125;&#125;\n\n构建算法实现12345678910111213141516171819202122232425262728293031323334//HT为地址传递的存储哈夫曼树的数组，w为存储结点权重值的数组，n为结点个数void CreateHuffmanTree(HuffmanTree *HT, int *w, int n)&#123;    if(n&lt;=1) return; // 如果只有一个编码就相当于0    int m = 2*n-1; // 哈夫曼树总节点数，n就是叶子结点    *HT = (HuffmanTree) malloc((m+1) * sizeof(HTNode)); // 0号位置不用    HuffmanTree p = *HT;    // 初始化哈夫曼树中的所有结点    for(int i = 1; i &lt;= n; i++)    &#123;        (p+i)-&gt;weight = *(w+i-1);        (p+i)-&gt;parent = 0;        (p+i)-&gt;left = 0;        (p+i)-&gt;right = 0;    &#125;    //从树组的下标 n+1 开始初始化哈夫曼树中除叶子结点外的结点    for(int i = n+1; i &lt;= m; i++)    &#123;        (p+i)-&gt;weight = 0;        (p+i)-&gt;parent = 0;        (p+i)-&gt;left = 0;        (p+i)-&gt;right = 0;    &#125;    //构建哈夫曼树    for(int i = n+1; i &lt;= m; i++)    &#123;        int s1, s2;        Select(*HT, i-1, &amp;s1, &amp;s2);        (*HT)[s1].parent = (*HT)[s2].parent = i;        (*HT)[i].left = s1;        (*HT)[i].right = s2;        (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;    &#125;&#125;","slug":"哈夫曼树","date":"2024-11-16T06:48:22.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"be74305dcdfd13488949087b92f952ec","title":"配置QT","content":"刚刚成功在QT上配置了安卓开发系统，顺便写一个教程吧。\n开发环境配置安卓系统开发需要三个东西：JDK，SDK，NDK。首先JDK直接从官网下下来就可以了，下载好后QT会直接在磁盘上检索，不需要手动设置路径。SDK，NDK可以直接从QT上下下来，安装好后就会显示安卓设置完成。OpenSSL一般是默认安装的，这个可以不需要，它主要是用来实现 SSL&#x2F;TLS 协议和提供AES、DES等加密算法的。\n虚拟机配置如果没有安卓系统的设备，还需要安装一个虚拟机环境，可以直接在SDK管理器中安装，找到Android Emulator并下载。重启QT后，可以看到在Kit中出现了安卓套件，点击“添加设备”，选择“Android”设备类型，这个时候可能会提示“创建AVD，请先从SDK管理器标签中安装系统镜像”。我们可以回到Android SDK管理器，安装Android 10.0(Q)，之后再去创建设备，就成功了。\n项目配置接下来就可以创建android项目了，我们在kit中选择Clang armeabi-v7a或者Clang x86_64。这一步选择很重要，因为生成的 APK 文件使用的指令集可能与手机设备支持的 ABI 不匹配。因此需要检查虚拟机的CPU架构，如果想要为实体机开发apk，一般选择Clang armeabi-v7a&#x2F;v8a。创建项目完后可以开始开发项目了，如果想要生成apk直接点击左下角的“构建项目”即可，会在输出路径底下生成一个.apk文件。如果是使用Release进行编译，还需要配置密钥存储库，直接在“项目”选项中点击创建即可，将.keystore文件保存在本地，之后再运行Release就可以构建成功。\n","slug":"配置QT","date":"2024-11-15T11:49:10.000Z","categories_index":"","tags_index":"配置","author_index":"Math-zhuxy"},{"id":"e89c78349414451d23c7b39518c39b85","title":"算法目录","content":"贪心\n区间问题\nHuffman树\n排序不等式\n绝对值不等式\n堆公式\n\n动态规划\n背包问题\n线性DP\n区间DP\n计数类DP\n数位统计DP\n状态压缩DP\n树形DP\n记忆化搜索\n\n数学知识\n质数\n约数\n欧拉函数\n快速幂\n扩展欧几里得算法\n中国剩余定理\n高斯消元\n求组合数\n容斥原理\n博弈论\n\n搜索与图论\nDFS\nBFS\n树与图的深度优先遍历\n树与图的广度优先遍历\n拓扑排序\nDijkstra\nbellman-ford\nspfa\nFloyd\nPrim\nKruskal\n染色法判定二分图\n匈牙利算法\n\n","slug":"目录","date":"2024-10-27T07:58:16.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":"简介并查集可以用来干什么的：将两个集合合并询问两个元素是否在一个集合中暴力做法：belong[x]&#x3D;a表示x在集合a中，但是合并的操作很难近乎O(1)的时间复杂度内完成两个操作基本原理：每个节点用一个树来表示，树根的编号就是整个集合的编号每个节点存储它的父节点用p[x]表示x节点的父节点，如果p[x]&#x3D;&#x3D;x表示树根如何求x的集合编号：一路往上找，直到树根：\n1while(p[x]!=x)x=p[x];\n如何合并两个集合：把集合2的p[]设成集合1树根：p[2_root]&#x3D;1_root;优化：假设集合树有一个路径A-&gt;B-&gt;C-&gt;Root注意到A，B，C都是Root的集合，如果我们要查询A，需要x&#x3D;p[x]多次，我们可以直接设置p[A,B,C]&#x3D;Root优化：路径压缩\n123456789101112131415161718192021const int N = 10010;int p[N];int find(int x)&#123;    if(x!=p[x])p[x]=find(p[x]);    return p[x];&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)p[i]=i;    while(m--)&#123;        char op[2];        int a,b;        scanf(&quot;%s%d%d&quot;,*op,&amp;a,&amp;b);        if(op[0]==&#x27;I&#x27;)p[find(x)]=find(b);        else if(op[0]==&#x27;Q&#x27;)&#123;            if(find(a)==find(b))printf(&quot;Yes\\n&quot;);            else printf(&quot;No\\n&quot;);        &#125;    &#125;&#125;","slug":"并查集","date":"2024-10-26T15:03:22.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"0b051914180f3217ee5468b2e6dfab33","title":"单调队列","content":"入门有一个大小为k的滑动窗口，它从数组的的最左边移动到最右边只能在窗口中看到k个数字，每次滑动窗口有向右移动一个位置。确定对于滑动窗口的每个位置，输出窗口的最大值和最小值。假设目前的队列排列如下：1 3 -1 -5 -3注意到：3比1大，因此只要3在队列中，1就不会成为最大值，而1要比3先弹出，即3在的时候1一定在，因此最大值一定不会是1，我们可以把1删掉。我们删掉所有这些元素后，剩下的就是一个单调递减的队列：3 -1 -5 。我闷需要最大值只需要输出队首即可。求最小值同理。总的来说，单调队列有以下几点特点：\n\n用普通队列怎么做\n将队列中的冗余元素删掉\n队列将具有某种性质（比如单调性）\n可以从一个特殊的位置取出最值代码如下：12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 1000010;int arr[N],q[N];int main()&#123;    int hh=0,tt=-1;    int n,k;    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    //cin&gt;&gt;n&gt;&gt;k;    for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;arr[i]);    for (int i = 0; i &lt; n; i ++ )    &#123;        if(q[hh]&lt;=i-k)hh++;        while(hh&lt;=tt&amp;&amp;arr[q[tt]]&gt;=arr[i])tt--;        q[++tt]=i;        if(i&gt;=k-1)printf(&quot;%d &quot;,arr[q[hh]]);    &#125;    printf(&quot;\\n&quot;);    hh=0;tt=-1;    for(int i=0;i&lt;n;i++)    &#123;        if(q[hh]&lt;=i-k)hh++;        while(hh&lt;=tt&amp;&amp;arr[q[tt]]&lt;=arr[i])tt--;        q[++tt]=i;        if(i&gt;=k-1)printf(&quot;%d &quot;,arr[q[hh]]);    &#125;    return 0;&#125;\n\n","slug":"滑动窗口","date":"2024-10-22T11:49:10.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"c47cb33c3a9e2a1822b846972febc26e","title":"双链表","content":"有三个数组：e表示这个点的值是多少，l表示每个点左边的点是什么，r表示右边的点是什么，idx每次更新一个点就++；初始化：0表示左端点，1表示右端点0:head,1:tailr[0]&#x3D;1;l[1]&#x3D;0;idx&#x3D;2;&#x2F;&#x2F;0,1已经被占用了\n在第k个点的右边插入一个点x：赋值：e[idx]&#x3D;valr[idx]&#x3D;r[k]l[r[k]]&#x3D;idxr[k]&#x3D;idx\n删除:删除第k个点:r[l[k]]&#x3D;r[k];l[r[k]]&#x3D;l[k];\n总代码如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int m;int e[N], l[N], r[N];int idx;//! 初始化void init()&#123;    l[1] = 0, r[0] = 1;//* 初始化 第一个点的右边是 1   第二个点的左边是 0    idx = 2;//! idx 此时已经用掉两个点了&#125;//* 在第 K 个点右边插入一个 X void add(int k, int x)&#123;    e[idx] = x;    l[idx] = k;    r[idx] = r[k]; //todo 这边的 k 不加 1 ， 输入的时候 k+1 就好    l[r[k]] = idx;    r[k] = idx;    idx++;&#125;//! 当然在 K 的左边插入一个数 可以再写一个 ， 也可以直接调用我们这个函数，在 k 的左边插入一个 数 等价于在 l[k] 的右边插入一个数 add(l[k],x)//*删除第 k个 点void remove(int k)&#123;    r[l[k]] = r[k];    l[r[k]] = l[k];&#125;int main(void)&#123;    ios::sync_with_stdio(false);    cin &gt;&gt; m;    init();    while(m--)    &#123;        string op;        cin &gt;&gt; op;        int k, x;        if(op==&quot;R&quot;)        &#123;            cin &gt;&gt; x;            add(l[1], x); //!   0和 1 只是代表 头和尾  所以   最右边插入 只要在  指向 1的 那个点的右边插入就可以了        &#125;        else if(op==&quot;L&quot;)//! 同理  最左边插入就是 在指向 0的数的左边插入就可以了   也就是可以直接在 0的 有右边插入        &#123;            cin &gt;&gt; x;            add(0, x);        &#125;        else if(op==&quot;D&quot;)        &#123;            cin &gt;&gt; k;            remove(k + 1);        &#125;        else if(op==&quot;IL&quot;)        &#123;            cin &gt;&gt; k &gt;&gt; x;            add(l[k + 1], x);        &#125;        else        &#123;            cin &gt;&gt; k &gt;&gt; x;            add(k + 1, x);        &#125;        &#125;    for(int i = r[0]; i != 1; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;    return 0;&#125;\n我的代码:\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int N=100010;int e[N];int l[N];int r[N];int idx=2;void init()&#123;    l[1]=0;    r[0]=1;    r[1]=-1;    l[0]=-1;&#125;void add_r(int k,int x)&#123;    e[idx]=x;    r[idx]=r[k];    l[r[k]]=idx;    r[k]=idx;    l[idx]=k;    idx++;&#125;void add_l(int k,int x)&#123;    e[idx]=x;    r[idx]=k;    l[idx]=l[k];    r[l[k]]=idx;    l[k]=idx;    idx++;&#125;void remove(int k)&#123;    r[l[k]]=r[k];    l[r[k]]=l[k];&#125;int main()&#123;    int n;    init();    scanf(&quot;%d&quot;,&amp;n);    while(n--)&#123;        string a;        cin&gt;&gt;a;        if(a==&quot;R&quot;)&#123;            int x;            cin&gt;&gt;x;            add_l(1,x);        &#125;        if(a==&quot;L&quot;)&#123;            int x;            cin&gt;&gt;x;            add_r(0,x);        &#125;        if(a==&quot;D&quot;)&#123;            int x;            cin&gt;&gt;x;            remove(x+1);        &#125;        if(a==&quot;IL&quot;)&#123;            int k,x;            cin&gt;&gt;k&gt;&gt;x;            add_l(k+1,x);        &#125;        if(a==&quot;IR&quot;)&#123;            int k,x;            cin&gt;&gt;k&gt;&gt;x;            add_r(k+1,x);        &#125;    &#125;    for(int i=r[0];i!=1;i=r[i])&#123;        cout&lt;&lt;e[i]&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;","slug":"双链表","date":"2024-10-20T12:32:20.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"599e3a777e3c1f587525e8b550969355","title":"单链表","content":"这是一种用数组模拟链表的方法，因为在C++中new方法需要的时间较久，因此需要使用一种方式通过下标来快速的实现链表的操作。有几个关键的值和数组：head表示头节点下标e[i]表示下标为i的节点的值ne[i]表示下标为i的节点指向的下一个节点的下标idx存储我们操作的节点的下标idx表示链表中插入的第idx个节点的位置下标就是链表中的指针下面给出代码模板：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;using namespace std;const int N = 100010;int head,e[N],ne[N],idx;//head表示头节点下标//e[i]表示下标为i的节点的值//ne[i]表示下标为i的节点指向的下一个节点的下标//idx存储我们操作的节点的下标//下标就是链表中的指针//初始化void init()&#123;    head=-1;    idx=0;&#125;//把x插到头节点void add_head(int x)&#123;    //第三步，把x存入新的节点    //node-&gt;value=x;    e[idx]=x;        //第一步，把新的节点指向的值变为head指向的值    //新节点的next指针指向原本的head的next指针    //node=new NODE();    //node-&gt;next=head-&gt;next;    ne[idx]=head;    //idx这是也代表这是链表的第几个点        //第二步，head的next指针指向idx    //head-&gt;next=node;    head=idx;            //我的idx已经被用过了，因此我的idx移动到下一个位置    idx++;&#125;//将x插入到下标为k的点的后面void add(int k,int x)&#123;    //node-&gt;value=x;    e[idx]=x;    //node-&gt;next=list[k]-&gt;next;    ne[idx]=ne[k];    //list[k]-&gt;next=node;    ne[k]=idx;    idx++;&#125;//将下标是k的点的后面的点删掉void remove(int k)&#123;    ne[k]=ne[ne[k]];&#125;int main()&#123;    int m;    cin&gt;&gt;m;    init();    while (m -- )&#123;        char a;        cin&gt;&gt;a;        int k,x;        if(a==&#x27;H&#x27;)&#123;            cin&gt;&gt;x;            add_head(x);        &#125;        else if(a==&#x27;D&#x27;)&#123;            cin&gt;&gt;k;            if(k==0)head=ne[head];            else remove(k-1);        &#125;        else if(a==&#x27;I&#x27;)&#123;            cin&gt;&gt;k&gt;&gt;x;            add(k-1,x);        &#125;    &#125;    for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27; ;    return 0;&#125;","slug":"单链表","date":"2024-10-20T12:24:58.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"b15a3d80cccdf73982f5b8a5b568cf91","title":"spfa","content":"分析SPFA算法仅仅只是Bellman_ford算法的一个优化。Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。\n值得注意的是\nst数组的作用：判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。即便不使用st数组最终也没有什么关系，但是使用的好处在于可以提升效率。\n\nSPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的:\n\nDijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就不可逆了(不可标记为true后改变为false)；SPFA算法中的st数组仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。\nDijkstra算法里使用的是优先队列保存的是当前未确定最小距离的点，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是记录一下当前发生过更新的点。\nBellman_ford算法里最后return-1的判断条件写的是dist[n]&gt;0x3f3f3f3f&#x2F;2;而spfa算法写的是dist[n]&#x3D;&#x3D;0x3f3f3f3f;其原因在于Bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是SPFA算法不一样，它相当于采用了BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。\nBellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是SPFA算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环。\n由于SPFA算法是由Bellman_ford算法优化而来，在最坏的情况下时间复杂度和它一样即时间复杂度为 $O(nm)$\n\n\n\n ，假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。(好像SPFA有点小小万能的感觉?)。    6) 求负环一般使用SPFA算法，方法是用一个cnt数组记录每个点到源点的边数，一个点被更新一次就+1，一旦有点的边数达到了n那就证明存在了负环。\n代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N=1e5+10;#define fi first#define se secondtypedef pair&lt;int,int&gt; PII;//到源点的距离，下标号int h[N],e[N],w[N],ne[N],idx=0;int dist[N];//各点到源点的距离bool st[N];int n,m;void add(int a,int b,int c)&#123;    e[idx]=b;w[idx]=c;ne[idx]=h[a];h[a]=idx++;&#125;int spfa()&#123;    queue&lt;PII&gt; q;    memset(dist,0x3f,sizeof dist);    dist[1]=0;    q.push(&#123;0,1&#125;);    st[1]=true;    while(q.size())&#123;        PII p=q.front();        q.pop();        int t=p.se;        st[t]=false;//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队        for(int i=h[t];i!=-1;i=ne[i])&#123;            int j=e[i];            if(dist[j]&gt;dist[t]+w[i])&#123;                dist[j]=dist[t]+w[i];                if(!st[j])&#123;//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率                    st[j]=true;                    q.push(&#123;dist[j],j&#125;);                &#125;            &#125;        &#125;    &#125;    if(dist[n]==0x3f3f3f3f) return -1;    else return dist[n];&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    memset(h,-1,sizeof h);    while(m--)&#123;        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        add(a,b,c);    &#125;    int res=spfa();    if(res==-1) puts(&quot;impossible&quot;);    else printf(&quot;%d&quot;,res);    return 0;&#125;","slug":"spfa","date":"2024-10-17T08:22:06.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"7ff27b21dc778d80ff5e8e51d9209bee","title":"Dijkstra","content":"介绍迪杰斯特拉算法采用的是一种贪心的策略。\n求源点到其余各点的最短距离步骤如下：\n\n用一个 dist 数组保存源点到其余各个节点的距离，dist[i] 表示源点到节点 i 的距离。初始时，dist 数组的各个元素为无穷大。用一个状态数组 state 记录是否找到了源点到该节点的最短距离，state[i] 如果为真，则表示找到了源点到节点 i 的最短距离，state[i] 如果为假，则表示源点到节点 i 的最短距离还没有找到。初始时，state 各个元素为假。\n\n源点到源点的距离是0.即 dist[i]&#x3D;0\n\n遍历 dist 数组，找到一个节点，这个节点是：没有确定最短路径的节点中距离源点最近的点。假设该节点编号为 i。此时就找到了源点到该节点的最短距离，state[i] 设为 1。\n\n遍历 i 所有可以到达的节点 j，如果 dist[j] 大于 dist[i] 加上 i -&gt; j 的距离，即$$dist[j] &gt; dist[i] + w[i][j]（w[i][j] 为 i -&gt; j 的距离）$$ ，则更新 dist[j] &#x3D; dist[i] + w[i][j]。\n\n重复 3 4 步骤，直到所有节点的状态都被置为 1。\n\n此时 dist 数组中，就保存了源点到其余各个节点的最短距离。\n\n\n代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 510, M = 100010;int h[N], e[M], ne[M], w[M], idx;//邻接表存储图int state[N];//state 记录是否找到了源点到该节点的最短距离int dist[N];//dist 数组保存源点到其余各个节点的距离int n, m;//图的节点个数和边数void add(int a, int b, int c)//插入边&#123;    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;void Dijkstra()&#123;    memset(dist, 0x3f, sizeof(dist));//dist 数组的各个元素为无穷大    dist[1] = 0;//源点到源点的距离为置为 0    for (int i = 0; i &lt; n; i++)    &#123;        int t = -1;        for (int j = 1; j &lt;= n; j++)//遍历 dist 数组，找到没有确定最短路径的节点中距离源点最近的点t        &#123;            if (!state[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))                t = j;        &#125;        state[t] = 1;//state[i] 置为 1。        for (int j = h[t]; j != -1; j = ne[j])//遍历 t 所有可以到达的节点 i        &#123;            int i = e[j];            dist[i] = min(dist[i], dist[t] + w[j]);//更新 dist[j]        &#125;    &#125;&#125;int main()&#123;    memset(h, -1, sizeof(h));//邻接表初始化    cin &gt;&gt; n &gt;&gt; m;    while (m--)//读入 m 条边    &#123;        int a, b, w;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;        add(a, b, w);    &#125;    Dijkstra();    if (dist[n] != 0x3f3f3f3f)//如果dist[n]被更新了，则存在路径        cout &lt;&lt; dist[n];    else        cout &lt;&lt; &quot;-1&quot;;&#125;","slug":"Dijkstra","date":"2024-10-17T08:21:57.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"f9c5a67ed89813cc4d2fda9f690375dd","title":"Trie","content":"问题为什么链表，Trie树和堆会用到idx来维护这个数据结构，而栈和队列就不用idx来维护，而是用hh和tt来维护呢？\n解答可以看出不管是链表，Trie树还是堆，他们的基本单元都是一个个结点连接构成的，可以成为“链”式结构。这个结点包含两个基本的属性：本身的值和指向下一个结点的指针。按道理，应该按照结构体的方式来实现这些数据结构的，但是做算法题一般用数组模拟，主要是因为比较快。各个节点之间用idx联系起来。idx的操作总是idx++，这就保证了不同的idx值对应不同的结点，这样就可以利用idx把结构体内两个属性联系在一起了。因此，idx可以理解为结点。\n链表：链表中会使用到这几个数组来模拟：\n&#x2F;&#x2F; head存储链表头指向的节点，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点h, e[N], ne[N], idx;h表示头结点指针，一开始初始化指向-1，每次插入x的操作idx++。利用idx联系结构体本身的值和next指针，因此e[idx]可以作为结点的值，ne[idx]可以作为next指针。同理可以理解双链表。\n1234567891011121314151617181920212223242526272829303132333435//单链表void add_to_head (int x)&#123;    e[idx] =  x;    ne[idx] = h;    h = idx ++ ;&#125;//双链表// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点void insert(int a,  int x)&#123;    e[idx] = x;    l[idx] = a;    r[idx] = r[a];    l[r[a]] = idx;    r[a] = idx ++;&#125;```C++Trie树Trie树中有个二维数组 son[N][26]，表示当前结点的儿子，如果没有的话，可以等于++idx。Trie树本质上是一颗多叉树，对于字母而言最多有26个子结点。所以这个数组包含了两条信息。比如：son[1][0]=2表示1结点的一个值为a的子结点为结点2;如果son[1][0] = 0，则意味着没有值为a子结点。这里的son[N][26]相当于链表中的ne[N]。```C++void insert(char str[])&#123;    int p = 0; //从根结点开始遍历    for (int i = 0; str[i]; i ++ )    &#123;        int u =str[i] - &#x27;a&#x27;;        if (!son[p][u]) son[p][u] = ++ idx; //没有该子结点就创建一个        p = son[p][u]; //走到p的子结点    &#125;    cnt[p] ++; // cnt相当于链表中的e[idx]&#125;\n堆堆中的每次插入都是在堆尾，但是堆中经常有up和down操作。所以结点与结点的关系并不是用一个ne[idx][2]可以很好地维护的。但是好在堆是个完全二叉树。子父节点的关系可以通过下标来联系（左儿子2n，右儿子2n+1）。就数组模拟来说，知道数组的下标就知道结点在堆中的位置。所以核心就在于即使有down和up操作也能维护堆数组的下标（k）和结点（idx）的映射关系。 比如说：h[k] &#x3D; x, h数组存的是结点的值，按理来说应该h[idx]来存，但是结点位置总是在变的，因此维护k和idx的映射关系就好啦，比如说用ph数组来表示ph[idx] &#x3D; k, 那么结点值为h[ph[idx]], 儿子为ph[idx] * 2和ph[idx] * 2 + 1, 这样值和儿子结点不就可以通过idx联系在一起了吗？\n123456789if (op == &quot;I&quot;)&#123;    scanf(&quot;%d&quot;, &amp;x);    size ++ ;    idx ++ ;    ph[idx] = size, hp[size] = idx;//每次插入都是在堆尾插入    h[size] = x;//h[k], k是堆数组的下标，h存储的是结点的值，也就是链表中的e[idx]    up(size);&#125;\n由于idx只有在插入的时候才会更新为idx ++，自然idx也表示第idx插入的元素。\nTrie树用来快速存储字符串集合的树（字母类型不会很多）。集合的数据结构。字符串：abcdefabdefacedbcdc具体代码实现：\n123456789101112131415161718192021int son[N][26],cnt[N],idx;//idx=0表示根节点void insert(char str[])&#123;    int p=0;    //str[i]如果为&#x27;\\0&#x27;表示字符串尾    for(int i = 0; str[i]; i ++ )&#123;        int u=str[i]-&#x27;a&#x27;;        if(son[p][u]==0)son[p][u]=++idx;        p=son[p][u];    &#125;    cnt[p]++;&#125;int find(char str[])&#123;    int p=0;    for(int i=0;str[i];i++)&#123;        int u=str[i]-&#x27;a&#x27;;        if(son[p][u]==0)return 0;        p=son[p][u];    &#125;    return cnt[p];&#125;\n例题最大异或和：给定$N$个整数，$A_1,A_2,…A_N$，从当中任意挑两个整数，问最大的异或值是多少。假设$A_i&#x3D;10010…1$我们先看最高位，如果有一个$A_j$它的最高位是0，那么它的异或结果将比较大，对这些$A_j$组成的集合再进行筛查：看第二高位与$A_i$是否不一样，依次类推…\n123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;const int N=100010,M=3000000;int arr[N];int son[M][2],idx;void insert(int x)&#123;    int p=0;    for(int i = 30; ~i; i--)&#123;        int&amp; s=son[p][x&gt;&gt;i &amp; 1];        if(!s)s=++idx;        p=s;    &#125;&#125;int query(int x)&#123;    int res=0,p=0;    for(int i= 30; ~i;i--)&#123;        int s=x&gt;&gt;i&amp;1;        if(son[p][!s])&#123;            res+=1&lt;&lt;i;            p=son[p][!s];        &#125;        else p=son[p][s];    &#125;    return res;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;arr[i]);        insert(arr[i]);    &#125;    int res=0;    for(int i=0;i&lt;n;i++)res=max(res,query(arr[i]));    printf(&quot;%d&quot;,res);&#125;","slug":"Trie","date":"2024-10-17T08:21:29.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"750466a07204eea158a8ccd364ba109b","title":"BFS","content":"简介BFS其实和DFS很像，也是一种树的遍历，只不过BFS每次都会先把某一深度的节点全部遍历完再搜索下一个深度的节点。思路从起点开始，往前走第一步，记录下所有第一步能走到的点，然后从所第一步能走到的点开始，往前走第二步，记录下所有第二步能走到的点，重复下去，直到走到终点。输出步数即可。\n代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 110;int g[N][N];//存储地图int f[N][N];//存储距离int n, m;void bfs(int a, int b)//广度优先遍历&#123;    queue&lt;PII&gt; q;    q.push(&#123;a, b&#125;);    //初始点的距离为 0.    //可以不要这一句，因为f初始化的时候，各个点为0    f[0][0] = 0;    while(!q.empty())    &#123;        PII start = q.front();        q.pop();        //这一句可以不要，因为入队的时候就置为了1        g[start.first][start.second] = 1;        int dx[4] = &#123;0, 1, 0, -1&#125;, dy[4] = &#123;-1, 0, 1, 0&#125;;        for(int i = 0; i &lt; 4; i++)//往四个方向走        &#123;            //当前点能走到的点            int x = start.first + dx[i], y = start.second + dy[i];            //如果还没有走过            if(g[x][y] == 0)            &#123;                //走到这个点，并计算距离                g[x][y] = 1;                f[x][y] = f[start.first][start.second] + 1;//从当前点走过去，则距离等于当前点的距离+1.                //这个点放入队列，用来走到和它相邻的点。                q.push(&#123;x, y&#125;);            &#125;        &#125;    &#125;    cout &lt;&lt; f[n][m];&#125;int main()&#123;    memset(g, 1, sizeof(g));    cin &gt;&gt; n &gt;&gt;m;    for(int i = 1; i &lt;= n; i++)    &#123;        for(int j = 1; j &lt;= m; j++)        &#123;            cin &gt;&gt; g[i][j];        &#125;    &#125;    bfs(1,1);&#125;","slug":"BFS","date":"2024-10-17T08:20:47.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"3ffef40c161f2bcfcf068173b0dcabaa","title":"斯大林格勒战役","content":"引子斯大林格勒战役无疑是二战中最出名的战役，它是整个人类历史上规模最大，参战人数最多的战役，伤亡人员大约200万，平均一个士兵存活时间不到24小时，并成为第二次世界大战的转折点。\n介绍战役之前1942年以前，小胡子一直处于春风得意的状态。在西线，一战磕了四年的死对头“法国”被曼施坦因的装甲部队直接撕碎，仅仅坚持了39天就投降，其他一北欧小国如丹麦和挪威也纷纷投降；在东线，巴巴罗萨计划前期的进展极其顺利，德军在仅伤亡了十几万人的情况下，歼灭的苏军数百万的军队，成建制的苏军被德军击溃，俘虏。在明斯克-比亚韦斯托克战役（1941年6月22日 - 7月9日）、乌曼战役（1941年7月15日 - 8月8日）、基辅战役（1941年8月23日 - 9月26日）、维亚济马-布良斯克战役（1941年10月2日 - 10月13日）和哈尔科夫战役（1942年5月12日 - 5月28日）中德军一共俘虏了约200万苏军部队，德国前线局势大好。\n蓝色计划到了1942年3月底，情况出现了变化，最重要的就是德军的储油量不够了，机械化部队的移动都需要燃料，没有燃料就只能变成动不了的铁疙瘩，而德军的产油主要靠罗马尼亚的普洛耶什蒂油田和工业合成。因此，德国总参谋部提供了代号为蓝色计划的方案。具体来说，蓝色方案主要有三个目标：\n\n进攻苏联南部，占领高加索油田，特别是巴库油田\n控制伏尔加河流域，切断苏联的资源供给\n推进到苏联边境，阻止英美盟军向苏联提供物资援助，尤其是来自波斯的援助线路。\n\n整个蓝色计算的执行比较复杂，总共可以分为四个阶段：\n\n蓝色一号，从库尔斯克出发，直接抵达沃罗涅日\n蓝色二号，第一路从沃罗涅日出发向南，第二路从哈尔科夫出发向东，两路人马在米列罗沃汇合\n蓝色三号，第一路从米列罗沃出发向东穿过顿河，第二路从南边经过罗斯托夫，一路向东，两路人马在斯大林格勒门口会师。\n蓝色四号，全面进入高加索地区\n\n\n没必要的战斗在蓝色计划最初的方案中，完全没有斯大林格勒什么事，最多也就是在斯大林格勒郊区，然后炮火压制，干扰伏尔加河的物流。德国的参谋团队也不是吃素的，早就研究过这里不是特别好打的，这个城市背靠伏尔加河，所以它无论什么时候都是有补给的，德军很难完全地包围它。而且，整个蓝色方案分为了A集团军群和B集团军群。B集团军群负责沃罗涅日-斯大林格勒这条战线，主要作用是保护A集团军群的侧翼；而A集团军群才是主力，负责高加索地区，他们需要依次攻占科迈普油田、格罗兹尼油田、巴库油田。简化一下就是：在蓝色计划中，保卢斯所在第六集团军群的B集团军群只是起到了辅助的作用，结果最后却演变为B集团军群冲到城里和苏军血战，完全违背了蓝色计划的初衷。不少人认为斯大林格勒很重要，反复强调所谓的兵家必争之地。斯大林格勒背靠伏尔加河，现代化工厂林立，确实很重要。但苏联的重要城市很多，玩过钢4的都知道，苏联的胜利点很多，很多都在远东地区，一个个踩很费力，没办法很快瓦解。（大部分都是靠内奸渗透瓦解国家政治体系）就算莫斯科、列宁格勒、斯大林格勒全部失守，只要苏军沿着南北流向的河流纵深防御，同样能拦截德军的进攻。因此，斯大林格勒值得一试，但时候需要重兵血战，还值得商榷。\n蓝色计划初期蓝色行动原定在1942年5月底展开，但是因为部分参加行动的德军与罗马尼亚部队当时正在克里米亚半岛围攻赛瓦斯托波尔，导致蓝色行动数次被延误，而该城直至6月底还未陷落。德军同时在5月12日的哈尔科夫进攻战役中包围并切断苏军的突出部，于5月22日包围了大批苏联军队。蓝色行动最后在6月28日实施，南方集团军群开始对苏联南部的进攻。德军的攻势起初非常顺利，苏军在空旷的草原抵抗力薄弱并开始向东撤退，他们数次重新组建的防线均因德军的侧击而崩溃，形成7月2日在卡尔可夫东北部，与9日在米列罗沃附近的两个包围圈。而匈牙利第二军团及德国国防军第4装甲集团军已于6月28日在沃罗涅日战役中获胜，并于7月5日攻占该城，并最终在7月24日大获全胜，使1,310,000名苏军在罗涅日－沃洛什防御战役中付出了370,522人阵亡的代价。\n德意志国防军第6集团军进攻的成功使希特勒命令德国国防军第4装甲集团军转前往支援南面的A集团军群，第4装甲集团军与第6集团军因为同时使用该地区少数的道路而造成了严重的交通堵塞，最后两个集团军只得停止前进来疏散数以千计的车辆，导致部队的路程至少延误了一个星期。之后又因为第6集团军进攻斯大林格勒缓慢，希特勒又改变主意、命令第4装甲集团军重回斯大林格勒支援。到7月底，德军逼使苏军撤退到顿河对岸，而顿河与伏尔加河之间仅距离40公里，因此德军避开苏军在顿河以西的主要补给站，这令往后的战役发展有重大的影响。德军之后开始部署意大利、匈牙利及罗马尼亚等轴心联盟的部队来掩护其左（北）翼。当时德国第6集团军已前进到距离斯大林格勒只有40公里的地方，而第4装甲集团军当时正北进以帮助攻取该城。南方的A集团军群则正挺进高加索，但其进攻因为补给线过长而渐慢，两个集团军群之间亦因相距过远而无法互相支援。\n斯大林格勒战役此时斯大林格勒城内，苏军已作好准备。苏军利用船只渡过以对全城补给粮食、牛和铁路机车车辆，这样令苏军在德军攻击开始前暂时解决城市内粮食短缺的问题。一些工厂仍在生产，特别是其中一间还在生产T-34坦克。然而，在德国国防军到达前，德国空军已大规模轰炸伏尔加河，特别是切断进入该市之补给路线，令苏军船只不能使用，从7月25日至7月31日，32艘苏军船只被击沉，另外9艘被迫报废。\n这场战役是在由沃尔弗拉姆·冯·里希特霍芬男爵指挥的德国空军第4航空队对该市进行的猛烈轰炸中展开，该航空队在1942年夏季及秋季时是全世界最强大的航空队。数以千吨计的炸弹倾泻入市内，该市很快就变成一片废墟，然而城市中的一些工厂仍在继续生产，而且同时厂内的工人也参加了战斗。克罗地亚第369加强步兵师是唯一的非德国单位，被德国国防军选择在攻击行动中进入斯大林格勒城内进行战斗。\n为了防御，斯大林仓皇地派出所有可用之部队到伏尔加河东岸，其中一些士兵甚至来自遥远的西伯利亚，所有正式的渡轮很快被德国空军炸毁，因此这些部队需要乘坐用拖船拖着的驳船以缓慢地过河。斯大林又禁止居民从该市撤走，因他相信居民的存在会鼓励守军进行更顽强的抵抗，包括妇女及儿童的居民都被组织派往修筑战壕及防御工事。德军在8月23日的一次大规模战略轰炸导致一场火灾旋风，造成数千人的死亡，并将斯大林格勒市区内一大片城区烧成残垣断壁。在捷尔任斯基区，百分之九十的住宅被破坏。从8月23日至8月26日间，苏军的报告指出轰炸共导致955人死亡及1,181人受伤。8月25日后，苏军再也没有记录因轰炸而造成平民及军事上的伤亡数字。\n此时，在斯大林格勒部署的苏军空军部队已经被德国空军驱散，在8月23日至8月31日间苏军于紧密作战区域就损失了201架战机。虽然在8月份得到100余架的补充，但其仍然只有192架可供使用的飞机，其中只有57架是战斗机。即使苏军在9月底对斯大林格勒持续投入空军增援，但是受到巨大的损失。德国空军完全掌握了该空域的制空权。不过由于苏联在1941年就进行了工业搬迁，苏联的飞机生产数字在1942年下半年就已达到15,800架，这能确保保留足够兵力及建立预备队，并最终在后期阶段于数量上超越德国空军。\n最初斯大林格勒的防守重任落在第1077防空团身上，该团主要由年轻女性自愿者组成，她们没有受过射击地面目标的训练。虽然如此，在没有其它苏军单位增援的情况下，该团仍坚守防御阵地并攻击前来的德军坦克，德军第16装甲师报告曾与第1077团的高射炮兵交战直至37门高射炮尽数被击毁或停止抵抗。在作战过程中，第16装甲师亦发现因苏军兵力短缺——他们已经与一些女性士兵交战。在斯大林格勒防御战开始时，苏军广泛地依赖工人民兵即没有直接参与军工生产的武装工人进行战斗。有时候，坦克刚刚从生产线下来就由工厂的工人驾驶驶至前线。很多时候这样的战车因为没有迷彩涂装而成为最直接的攻击目标。\n至8月底，南方B集团军群群最终到达位于斯大林格勒北边的伏尔加河，接着他们就向伏尔加河南面的另一边发动进攻。9月1日，苏军不得不冒着被德军炮击和轰炸的危险横渡伏尔加河，以对斯大林格勒城内的守军进行增援及补给。\n9月5日，苏联第62及第64集团军群对德国第14装甲军发起大规模反攻，而德国空军则对苏军炮兵据点及防线实施大规模轰炸以帮助德军地面部队击退苏军的这次攻击。由于空袭，苏军在发动反攻数小时后就被迫在中午撤退。参与此次进攻的120辆苏军坦克中，有30辆被德空军炸毁。\n苏军的行动持续受到德国空军的干扰，9月18日苏联第1近卫军及第24军在科特鲁班对德国第8军实施反攻期间，德国空军第8航空军派遣一波又一波的斯图卡俯冲轰炸机以阻止苏军突破该战线。苏军的攻势最终落败。事后，第8航空军报告斯图卡俯冲轰炸机在这天早上击毁了106辆坦克中的41辆，同时Bf 109战斗机也击落了77架苏军飞机。\n为了守卫这座满目疮痍的城市，苏联第62和第64集团军群包括苏军第13近卫步枪师在居民楼及工厂中建立了了依托据点的防线。双方在废墟般的城市中进行着激烈而绝望的战斗。第13近卫步枪师由亚历山大·罗迪姆釆夫陆军少将指挥，他因该战役的英勇表现而授予苏联英雄称号。此时，在这个战场上，一名新到作战的苏军士兵平均生存时间已少于24小时，而一名苏军军官不多于3天。斯大林在1942年7月27日发出的第227号命令指出所有指挥官未经授权而擅自撤退将交付军事法庭审判，“不能后退一步”和“斯大林格勒后已没有土地”成为了战地口号。正因苏联人的顽抗，德军向斯大林格勒城内推进时亦付出了巨大的代价。\n德军的军事准则是基于协同作战及坦克、步兵、工兵、火炮及攻击机互相配合作战。有鉴于此，为了进行有效反击，苏军指挥官采用前线部队尽可能与德军近身距离作战的战术；崔可夫称这是让苏军和德军的战线交错。这迫使德军面对只能各自为战或面对被友军误伤的危险；这样令德军减少空中及炮火支援。虽然斯卡图轰炸机仍然可以在局部造成有效的杀伤，但是在大范围看，其造成的杀伤力远不如大型水平轰炸机。苏军明白在斯大林格勒，最好的防御是那些可监察具有重要战略意义的街道和广场的建筑物，这种战略令苏军可尽量长时间在所有地段坚守，因此他们把多层楼宇、工厂、仓库、街角住宅及办公楼转变为布满机枪、反坦克步枪、迫击炮、地雷、铁丝网、狙击手的死亡陷阱。苏军将5-10名冲锋枪枪手和掷弹兵组成一单位进行逐屋战斗，激烈的战斗在每一个废墟、街道、工厂、住宅、地下室及楼梯间进行，德军称这种看不见的城镇战为“老鼠战争“，并对这种“已经攻占了厨房，但仍然在争夺卧室与客厅”的战争加以酸溜溜地讥讽。在这种绝望的混乱中，所有战线均消失，习惯了进行机动作战的德军士兵被迫投入艰苦而快速的战斗，包括在炸毁的居民区、办公区、地下室和公寓高楼大厦前进。建筑中往往可以看到一楼是苏军，二楼是德军，三楼还是苏军，空中是德军飞机，楼外是装甲坦克的局面，残酷的巷战发生在这座城市的每一个角落。\n战斗进行到9月12日时，苏联第62集团军群只剩下90辆坦克、700门迫击炮及大约20,000名士兵。苏军第13近卫步兵师在9月13日被授与了收复马马耶夫岗及一号火车站的任务，因而遭到了巨大的损失，其中超过百分之三十的士兵在战斗的头24小时内便阵亡了；这场战役后，全师原本的10,000人只有320人存活下来。以上两个目标均被苏军取得控制权，但这只是临时性的，火车站在6个小时内14度易手。到了第二天晚上，第13近卫步兵师全部阵亡，但该师士兵亦杀死了差不多同样数量的德军士兵。战斗在巨大的粮仓附近持续了数周，虽然经过了激烈的战斗，但当德军最后攻占该处时，发现苏军只有40人死亡，苏军在撤退前焚烧了堆放在这里的粮食。在城市的其它地区，一个排的苏军在雅科夫·巴甫洛夫的指挥下把一座可俯瞰市中心的大厦变成了坚不可摧的堡垒，后来这里被称为巴甫洛夫大楼，士兵在大楼周围埋下地雷，在窗户建立射击位，还把地下室之间的墙壁打通以建立更好的通讯联系，这栋楼在接下来的40多天内抵挡了德军的所有进攻。在该战役后，崔可夫开玩笑地说为了试图攻占巴甫洛夫大楼而阵亡的德军人数比攻占巴黎时的阵亡人数还多，巴甫洛夫中士也因这场战役的英勇行动而被授予苏联英雄称号。\n由于战斗没有结束的迹象，德军开始调动转移重型火炮进入市区，包括巨大的800毫米铁道炮，昵称朵拉。但没有尝试派部队跨越伏尔加河，从而使苏联能在东岸建立了大量的炮兵阵地，这些大炮连续轰击德军的阵地，同时苏军守军则将轰击所造成的废墟变成防御阵地。德军坦克在高达8米高的废墟中变得毫无用处，当它们能各前推进时，成为了在破烂建筑物中的苏军反坦克炮的攻击目标。\n在10月中旬，德国空军加紧对在西岸余的红军阵地进行轰炸。到这时，苏联空军的抵抗已不再有效，德国空军第4航空队在10月14日飞行2,000架次及投下600吨炸弹，同时德军步兵对在北部的三座工厂进行包围。斯图卡俯冲轰炸机第1、第2及第77中队已令在伏尔加河东岸的苏军炮兵静止，之后攻击试图对日益收缩的苏军包围圈进行补给增援的船只。第62集团军群已被切成两半，及由于对其供应船只的密集轰炸而陷于崩溃。\n面对苏军在伏尔加河仅有1,000-码（910-米）长的阵地，超过1,208架次的斯图卡俯冲轰炸机飞临上空以消灭他们，虽然面对猛烈的空袭，苏联第62集团军群仍然有47,000人及19辆坦克在西岸抗击德国第6集团军群及第4装甲集群军。\n德国空军到11月初仍保持制空权及苏联空军在日间完全不存在的，但在进行了20,000架次的飞行后，原本1,600架可用的起飞机已降至950架，其中原本480架轰炸机只剩下232架，虽然相对苏联空军来说在数量上仍然占有优势，第4航空队却无法阻挡日益增强的苏联空军力量。到反攻阶段时，苏联空军的兵力已经超过第4航空队。\n苏联的轰炸机部队在过去18个月当中已付出沉重的损失，因而只能在晚间行动，苏军从7月17日至11月19日期间于晚间在斯大林格勒及顿河河套地区飞行了11,317架次，这些空袭只做成了有限的破坏及仅有滋扰性的价值。\n经过三个月的杀戮和缓慢而昂贵的推进后，德军最终到达河岸，并攻占百分之九十已破烂的市区，且将残存的苏军切成两半。伏尔加河上的结冰阻止船只及拖船对守军进行补给。然而，战斗，特别是在马马耶夫岗的斜坡上和市内北部地区的工厂区，仍然激烈如昔。红色十月钢铁厂、捷尔任斯基拖拉机厂及巴里卡迪兵工厂已因此变得举世闻名，当苏军防守这些工厂时，工厂工人在接近战场的地方甚至有时在战场中修理坦克及武器；虽然没有接受过战斗训练，这些平民有时也会自告奋勇地驾驶坦克，以取代阵亡和受伤的士兵。\n天王星行动在秋季，苏联将领亚历山大·华西列夫斯基和格奥尔吉·朱可夫制订了在斯大林格勒地区的战略计划，他们计划将大量苏军集中至该城南北面的空旷地带。德军之北翼由缺乏训练、装备及士气的意大利、匈牙利及罗马尼亚军负责守卫，极其脆弱，这个弱点被苏军发现。该计划是在城市内阻击德军的进攻，然后攻击过度延伸及薄弱的德军侧翼和包围在斯大林格勒内的德军，行动的代号天王星。改计划将与进攻中央集团军群的火星行动同时实施。\n11月19日，红军实施天王星行动，由尼古拉·费多罗维奇·瓦图京指挥的苏军进攻部队包括三个足额的集团军，第1近卫集团军、第5坦克集团军及第21集团军，共有18个步兵师、8个坦克旅、2个机械化旅、6个骑兵旅及1个反坦克旅。这个进攻的准备被罗马尼亚人发现，他们要求增援但被拒绝。防线薄弱、兵员短缺及装备低劣的罗马尼亚第3集团军被击溃。11月20日，第二个苏军攻势在斯大林格勒南面实施，两个集团方面军迅速攻击防守该地的罗马尼亚第4集团军。只是由步兵组成的罗马尼亚军几乎立即崩溃，苏军在钳形攻势中向西前进，并于两天后的11月22日在卡拉奇附近会师，在斯大林格勒附近围成一个铁环，一共27万德军被包围。\n围剿包围的苏联红军立即组成2条防卫线：一条内对垒线面向里面，以阻止所有突围的尝试，及另一条外对垒线，以防止任何救援行动。\n阿道夫·希特勒于9月30日在柏林体育馆发表公开演说表示没有任何力量可以将德军从这个城市赶走。在苏军完成包围后的1次简短会议上，德军高层建议立即向顿河以西突围来建立新的战线，但戈林提出可以利用德军空军力量进行空投补给，希特勒最终决定令在城中的德军坚守阵地，不要突围。\n然而空运补给计划注定是一个蛇吞象的工程，第六集团军每日需要的最少补给是800吨，而德国空军最多只能空头106.6吨物资，为了填补空缺，德国人甚至开始使用一些不足以担任运输机角色的飞机，例如He-177轰炸机。\n空运补给的计划失败，恶劣的天气情况、技术上的失败、苏军高射炮的强大火力和战斗机的拦截导致德军损失488架飞机。德国空军甚至未能达到每天供应117吨的供应量，平均每日只有85吨补给物资被运到被围的德军手中。补给物资有时甚至没有什么用处：一架飞机运来20吨伏特加及夏季军服，另一个是黑胡椒和马玉兰。总体来说，第6集团军正在被慢慢地饿死。飞行员十分震惊地发现部队因过于疲惫及饥饿而没有能力卸下补给品，蔡茨勒将军因看见在斯大林格勒部队的困境而感动，开始限制自己每日的口粮餐次，几周后这种饮食次数令他变得非常憔悴，后来在希特勒恼怒的亲自命令下，才再开始吃正常的饮食次数。\n组织空运的代价是巨大的，共损失了266架Ju-52运输机，占苏德战线上总数的三分之一，空运中亦损失了165架He-111轰炸机，其它损失包括42架Ju-86轰炸机、9架Fw-200“秃鹰”飞机、5架He-177“鹰狮式”飞机及1架Ju-290飞机。德国空军亦失去了1,000名经验丰富的轰炸机机组人员。\n小土星行动苏联部队为集中他们在斯大林格勒周围的部队及开始进行激烈的战斗以缩小包围圈。同时，恶劣的俄罗斯冬季的影响浮现，伏尔加河河面结冰，令苏军更容易进行补给，被围的德军迅速的消耗了取暖燃料和医疗用品，数千士兵因冻伤、营养不良和疾病而死去。\n12月16日，苏军实施第二次进攻，即小土星行动，这行动是尝试突破轴心国在顿河的防线及攻占顿河畔罗斯托夫，如果成功，这一攻势将围困在高加索地区的其余南方集团军群，即整个在俄罗斯德国军队的三分之一，德军建立了机动防御，以小量单位防守城镇直至支援的装甲部队到达。15个师的苏军在最少100辆坦克的支援下从马蒙的桥头堡出发，攻击意大利的科塞里亚及拉文纳师，虽然处于1对9的劣势，意大利军一直抵抗至12月19日才因驻苏意大利军总司令部下令下才撤走。虽然苏军未曾接近顿河畔罗斯托夫，但战事却迫使冯·曼施坦因从高加索撤出A集团军群来重建由斯大林格勒向西延伸长达250公里的战线。\n第6集团军现在已没有希望获得任何的援助，在斯大林格勒的德军没有被告知这一点，相反，并继续认为增援正在途中。一些德军军官要求保卢斯违抗希特勒的命令，不再坚守及尝试突破在斯大林格勒的包围圈，保卢斯拒绝，因为他憎恶不服从命令的想法。而且，尽管在头几个星期利用机械化部队实施突围是有可能，但出于第6集团军现在缺乏汽油以及恶劣的俄罗斯冬季，德军士兵徒步突破苏军战线将是非常困难的。\n获胜在包围圈中的德军从斯大林格勒的郊外住宅区撤入市内。皮托尼克及古姆拉克两个飞机场先后失陷，导致德空运补给及撤出伤兵的行动终结。最后1个可使用的跑道是在斯大林格勒飞行学校，在这里最后1次降落在1月22日晚上至1月23日，在1月23日拂晓后，除空投弹药和食物外再没有更多关于起降的报导。\n德军现在不但陷于饥饿中，而且缺乏弹药。但是他们继续顽抗，部分原因是因为他们认为苏军将处死任何投降的人，特别是所谓的志愿助理人员，他们是协助德军作战的苏联公民，他们在被俘时已经对自己的命运不抱任何幻想。苏军最初对被围的德军人数感到意外，因此对包围部队实施增援。血腥的城市战在斯大林格勒再次展开，但这一次是德军被迫向伏尔加河岸边，他们在工厂区建立防御工事并进行凶猛的反抗。德军现在于城内没有可使用的坦克，这些坦克现在被当作固定大炮使用以发挥最大效用，苏军没有在这些地区使用坦克，因为废墟般的市区影响它们的机动性。1名苏军特使在1月24日向保卢斯提出优厚的投降条款：如果他在24小时内投降，他将得到由苏军提出的丰厚保障。但是保卢斯因希特勒“不得投降”的命令，而没有回应，直接导致第6集团军的毁灭。\n1943年1月30日，是希特勒获得权力10周年纪念，希特勒希望保卢斯会战斗到死或自杀，所以他晋升保卢斯为德国陆军元帅，毕竟德国历史上没有任何元帅成为战俘；但是当苏军于翌日接近他设在已成废墟的百货商场内的司令部时，保卢斯第一次也是最后一次违背了总统的命令，他决定投降向苏军投降，斯大林格勒北部剩下的轴心国军队也于1943年2月2日投降。\n结束在早些时间，德军曾最多攻占该城市的90%地区，然而苏军仍然进行激烈的抵抗。在战役中期的1942年11月19日－11月22日的天王星行动结束时，苏军已完全包围和围困的了第6集团军。而一部分德国第4装甲集团军之部队也在苏军反攻阶段时于战斗中付出了巨大的伤亡。\n德国国防军早期胜利的一个明显特征就是高度机动性。在斯大林格勒战役前，苏军只在莫斯科周围因其部队人数众多而获胜。斯大林格勒只不过是个军事价值有限且物资产能已经转移的地方，纳粹德国国防军陆军第6集团军本可绕过这处并集中力量联同A集团军群向高加索进击。但是希特勒选择了牺牲，将其最富有作战经验的部队投入在城市瓦砾中进行巷战，这对苏军有利及容许他们争取时间积聚及集中力量发动天王星行动，最终消灭整个第六集团军。\n斯大林格勒以惨烈著称，一名德军士兵指出他们一天损失约2,000名士兵。学者估计轴心国联军（德军以及其盟友）约伤亡841,000人（死亡、受伤或被俘），其中德国阵亡200,000—240,000人、受伤500,000人，被俘110,000人，罗马尼亚阵亡、受伤、被俘120,000人、匈牙利阵亡、受伤、被俘120,000人，意大利阵亡、受伤、被俘120,000人。在斯大林格勒战役中有110,000名德军士兵被俘，在去战俘营的死亡行军中75000人在三个月内死亡。所有战俘当中只有大约5,000人能在集中营存活下来，幸存的绝大部分在1955年被释放回到德国。德国战俘被分配到在苏联的各个劳动营中，在这里他们很多都因疾病（特别是斑疹伤寒）、寒冷、过度劳动、虐待及营养不良而死去，一部分战俘则被留下来重建城市。在1943年3月就有40,000名德国战俘被埋葬在万人坑中，苏方声称他们均是受斑疹伤寒感染而死亡的。少数高级官员被带到莫斯科，并用于宣传目的，其中有些人加入自由德国全国委员会。保卢斯一直住在苏联直到1952年，然后被迁回东德的德累斯顿，他在剩余的日子里捍卫他的行动，声称共产主义在1945年之后的欧洲是最有希望的。\n根据档案资料显示，苏军总伤亡人数共1,129,619人，其中有478,741人阵亡、650,878人受伤或生病。整个斯大林格勒地区共约有750,000名平民死亡、受伤或被俘。整场会战中苏联约处决了13,500名苏联士兵，相当于一个师。另外在1942年8月23日—8月26日的内，纳粹德国国防军空军第4航空队的飞机投下的1000吨炸弹的轰炸中有超过955人名苏联平民百姓死城内与郊区，在之后的死亡人数没有官方数字，数目不详。\n","slug":"斯大林格勒战役","date":"2024-10-15T10:23:42.000Z","categories_index":"","tags_index":"杂谈","author_index":"Math-zhuxy"},{"id":"9e3f215a3ac1a80702d532ae53dd204a","title":"法国战役","content":"引子二战时期的法国战役一直是人们“辱法”的最常用的例子。法国在二战中仅“坚持”了39天就投降，甚至不如苏德战场中斯大林格勒战役的一栋楼的守卫时间。自1940年5月10日战役爆发开始，德军在六周的时间内通过机动作战击败盟军部队，征服法国、比利时、卢森堡与荷兰。意大利于1940年6月10日加入战役，翻越阿尔卑斯山入侵法国。法国的沦陷标志着二战欧洲战场西线地面战事告一段落，直到1944年6月6日诺曼底登陆为止。\n想当然的计划1930年代，法国沿着德国边境建造了一系列防御工事，即马奇诺防线。该防线的目的是阻止德国跨越法德边境的入侵，将德军的攻击局限在比利时一带，此后法军便可用最精锐的部队迎击德军。如此便可将战事限制在法国领土之外，从而避免重蹈第一次世界大战的覆辙。马奇诺防线的主要部分南起法国-瑞士边境，北至卢森堡国界附近的隆维。防线的北端紧挨着森林茂盛的阿登地区。菲利普·贝当元帅宣称只要采取“特殊手段”，阿登地区就是“不可逾越”的。他相信任何自林区出现的敌军容易受到钳形攻势的打击而被消灭。法军总司令莫里斯·甘末林同样相信阿登地区不会遭到攻击，他认为该地“从不适合大规模行动”。1938年举办的法国兵棋推演场景便是德军自阿登地区发动了装甲攻势。这场推演给法国军方的印象是阿登地区依旧难以突破，而阿登地区和默兹河的阻碍足以让法军将部队调入这一地区发动还击。\n小胡子的考虑1939年10月9日，希特勒颁布了《元首第6号特别训令》。希特勒已经意识到必须在进攻东欧前通过军事行动打败西欧国家，从而避免双线作战的处境。然而《元首第6号特别训令》中并未体现这一目标。该计划基于较为现实的假设，认为德国需要花费数年时间建设军力；而在当下只能设想有限的目标，目的是提高德国在西线持久战中生存的能力。希特勒下令尽可能迅速地征服低地国家（即荷兰、比利时和卢森堡），以阻止法国先占领这些国家，并防止同盟国空军威胁德国重要的工业心脏—鲁尔区。此外，德军还可以占领的低地国家为基地，对英国实施长期的空中和海上攻击。元首训令没有提到迅速征服整个法国的计划，但确实提到需尽量多地进占法国北部的边境地区。\n尽管是书面指令，但希特勒原以为这样的攻击最多只需数周便可发起。然而希特勒误解了当时德军的真实状况。为修复在入侵波兰中损坏的车辆，摩托化单位预计需3个月才能恢复战力；此外军队弹药库存也十分匮乏。\n1939年10月10日，英国拒绝了希特勒提出的和平建议，法国随后在10月12日拒绝议和。10月19日，德国国防军陆军总司令部参谋长弗兰兹·哈尔德大将提出了“黄色方案”的第一版计划：《黄色方案第1号部署指令》，是入侵低地国家的行动代号。哈尔德的计划经常被与德国在1914年的第一次世界大战战略——施里芬计划相比。这两个计划都需要通过比利时中部发动进攻，但施利芬计划的意图是通过一次对法军的大规模包围歼灭战来获得决定性的胜利，而“黄色方案”寄望于正面攻击，预计将以牺牲50万名德军士兵的代价实现将盟军迫回索姆河的有限目标。德军在1940年的兵力将被耗尽，要等到1942年才能发动对法国的主要攻势。希特勒反对这一计划，提出希望像波兰战役一样发动决定性的装甲突破；但哈尔德和布劳希奇劝说他打消这一念头，辩称尽管快速移动的摩托化战术在对抗东欧的“残次品”军队时效果良好，对于法国这样的一等强军无法发挥作用。\n希特勒对哈尔德的计划很失望，他认为这是一个十分平庸且低效的计划，用他自己的话说，这是一个“军校生的点子”。他最初的反应是决定德国军队无论是否已经准备好都必需尽早进攻，希望趁盟军准备不足时轻松取胜。希特勒提出进攻应在1939年10月25日开始，后来认识到这一行动日期可能不现实。10月29日，哈尔德呈上《黄色方案第2号部署指令》，其中有向荷兰展开二次攻势的计划。11月5日，希特勒告知瓦尔特·冯·布劳希奇称他打算在11月12日开始入侵。布劳希奇回应道军队还未从波兰战役中回复，并向希特勒请辞；希特勒拒绝了布劳希奇的请求，两天后以天气不佳为由推迟了攻击时间。随后部队指挥官们又多次说服希特勒将进攻推迟数天乃至数周，以修正筹备工作的一些关键缺陷，或等待更好的天气条件。希特勒本人也尝试改变让他不满的作战计划，但他并不了解德国的战争准备工作有多差，也没有考虑德军会如何应对装甲车辆的损失。德军在波兰战役中很快取胜，但损失了许多装甲车，又很难换上新的车辆。希特勒对现况的无知最终导致他做出分散德国兵力的方案：德军的主要进攻仍旧会在比利时中部，但将在侧翼进行次要攻击。希特勒于11月11日提出了这一建议，对军方施压要求尽早攻击毫无准备的目标。\n希特勒并不是唯一不喜欢哈尔德计划的人。A集团军群司令格尔德·冯·伦德施泰特将军亦不同意该计划。伦德施泰特认为计划的基本缺陷是不符合德国自19世纪以来坚持的机动作战原则——必须以一次突破包围盟军主力，并将其最终消灭。为了实现机动作战的目标，唯一合理的突破地区是色当地区，它位于伦德施泰特的A集团军群战区内。10月21日，伦德施泰特与他的参谋长埃里希·冯·曼施坦因中将达成一致，认为必须基于色当突破这一基本构想安排作战计划，且需要以北面的B集团军群为代价尽可能保全A集团军群。\n当曼施坦因在科布伦茨制订新计划时，第19军司令海因茨·古德里安中将恰巧在附近的酒店。曼施坦因最初的计划考虑由色当向北进军，直插比利时的盟军主力的后方。当古德里安应邀参与该计划的非正式讨论时，他提出了一个激进的新想法。古德里安认为整个“装甲集群”应集中在色当，之后不应该转移到北部地区，而是向西部迅速插入至英吉利海峡，无须等候后续的步兵师大部队。这样的行动可能导致敌人战略上的崩溃，从而避免了传统包围战通常造成之相对较高的伤亡。这样高风险地独立使用装甲部队已在战前的德国受到广泛讨论，但德国陆军总司令部质疑这样的作战行动是否可行。古德里安在1914年和1918年随德国陆军亲身经历过阿登地区的环境，对该地的地形了如指掌，因此他对曼施坦因的总体计划立即表示了支持。\n曼施坦因于10月31日在他的备忘录中第一次概述了这一替代方案。他在备忘录中闭口不谈古德里安的名字，淡化了装甲部队的战略部分，以避免产生不必要的阻力。1939年11月6日至1940年1月12日之间，曼施坦因又陆续提交了六份备忘录，慢慢地提出越来越激进的计划轮廓。这些建议均被陆军总司令部拒绝，而且没有被送呈希特勒。\n1940年1月10日，一架德军梅塞施密特Bf 108飞机因大雾迷航，在比利时马斯特里赫特北面的马斯梅赫伦迫降，即后来的“梅赫伦事件”。德国空军要员赫尔穆·赖因贝格尔搭乘该机，正携带德国空军向比利时进攻的计划文件。赖因贝格尔未能销毁文件，因而这份计划很快地落入比利时的情报机构手中；但盟军情报机构怀疑这些文件是否是真实的计划。在1940年的满月期间，盟军又得到警报称德军可能向低地国家发动进攻；可能在穿过低地国家后从北部包抄马奇诺防线；可能直接攻打马奇诺防线；或者途径瑞士发起入侵。盟军警报的所有可能中都未考虑到德军进攻阿登的可能性；而在梅赫伦事件后，德军推定盟军对德国意图的认识会进一步加强。1月30日发布的《黄色方案第3号部署指令》只是对此前计划细节的修正；但到了2月24日，德军主要的努力方向换到了南方的阿登地区。20个师（含7个装甲师和3个摩托化师）从面对荷兰与比利时的B集团军群调动到面对阿登的A集团军群。法国军事情报部门发现德国的几个师从萨尔转移到摩泽尔北部，但未能发现从荷兰边境向艾费尔山-摩泽尔河地区的重新部署。\n1月27日，曼施坦因被解除A集团军群总参谋长的职务，调任东普鲁士的第38军司令。为了让曼施坦因沉默，哈尔德要求他于2月9日在斯德丁开始他的指挥工作。曼施坦因的下属向希特勒提出了作战计划的替代方案，而此时希特勒不顾总司令部的反对意见，自己提出了一项向阿登进军的建议。希特勒在2月2日获得了曼施坦因的方案。2月17日，希特勒召集曼施坦因、德军人事主管鲁道夫·施蒙特将军和国防军最高统帅部行动主管阿尔弗雷德·约德尔将军在柏林开会。\n希特勒认为曼施坦因的计划可能足以达成决定性胜利，于是第二天便下令按照曼施坦因的构想改变计划。希特勒只是从战术角度上了解了色当突破，而曼施坦因认为这一突破是终结战争的手段。他设想一项向英吉利海峡开展的军事行动，将盟军包围在比利时；计划的成功能造成战略影响。哈尔德随后产生了“令人惊讶的意见转变”，接受了主攻色当的想法。但是，哈尔德无意让A集团军群的7个装甲师作独立的战略穿插。1940年2月24日，《黄色方案第4号部署指令》发布；让古德里安愤怒的是，装甲师独立穿插的构想被完全删去。哈尔德受到的批评和他本人当初攻击曼施坦因时毫无二致。大多数德军军官感到震惊，并将哈尔德称为“坦克部队的掘墓人”。即使向常规方式作出了更多妥协，新计划还是引发了多数德军将领的抗议。他们认为不应如此不负责任地沿着容易被法军切断的路线，将部队集中于一个不可能得到充分补给的地方。如果盟军未像德军预期那样反应，该攻势最终可能造成灾难。不过哈尔德无视了他们的反对意见。哈尔德认为，由于德军的战略位置本来就毫无希望，即使获得决定性胜利的机会再细小也要全力争取。\n盟军策略埃斯科河计划（“E计划”）1939年9月3日对德宣战时，法国已经根据对地理、资源和人力的分析确定了军事战略。法军右翼将采取守势，而左翼将进入比利时，以推进法国战斗的前线。法军前进的程度取决与具体的事态。但在1936年3月7日莱茵兰重军事化之后，比利时中止了1920年签署的法国-比利时协定，使得法军面临的情况变得复杂。作为中立国，比利时拒绝与法国公开合作，但确实传达了有关比利时防御的讯息。到了1940年5月，法国和比利时已经交换了防务计划的总体讯息，但没有合作应对德国经卢森堡和比利时东部向西进攻。法国人预计德国首先会破坏比利时的中立，为法国干预提供借口；还有可能当入侵迫在眉睫时，比利时人会向法国求援。法国机动部队的大部分沿比利时边境集结，准备阻止德国人。\n如果比利时提早向法军求援，那么法军可能会有足够的时间到达德国-比利时边境；但如果法军未能及时赶到，在后方还有三条可行的防线。第一条防线从日韦到那慕尔，穿过“让布卢走廊”，经瓦夫尔和鲁汶，沿迪尔河到安特卫普，比其他的防线短70-80公里。第2条防线从法国边境到埃斯科河畔孔代、图尔奈，沿埃斯科河（即斯海尔德河）到根特，然后到达北海沿岸的泽布吕赫，可能继续沿着斯海尔德河到安特卫普。这一防线计划后来被称为“埃斯科河计划”或“E计划”。第三种布防方案是从卢森堡到敦刻尔克沿法国边境布防。对于战争的头两个星期，甘末林考虑到德国在波兰的快速推进，更倾向按照E计划布防。甘末林和其他法国指挥官怀疑在德国人到达之前法军无法推进到比E计划更远的地方。 9月下旬，甘末林向第1集团军群司令加斯东·比洛特发出指令：保卫国家领土完整，并在不撤出沿边境组织的抵抗阵地的情况下进行防御。1939年10月24日，甘末林指示，除非法军的推进速度足以提前制止德军，否则越过E计划防线继续进军绝不可行。\n迪尔河计划（“D计划”）到1939年末，比利时改善了阿尔伯特运河沿线的防御，提高了军队的戒备程度；甘末林和法国陆军总部开始考虑自埃斯科河进一步推进的可能性。到了11月，陆军总部决定进一步推进至迪尔河防线是可行的，但东北军区总司令阿尔方斯·乔治将军对能否赶在德国人前面到达迪尔河表示怀疑。英国对比利时的进展一直不冷不热，但甘末林说服了他们。11月9日，沿迪尔河防御的计划（“D计划”）被采纳。11月17日的一场最高战争委员会会议认定占领D计划防线至关重要。当天甘末林下达了一道指示，详细说明了一条从日韦经那慕尔、让布卢走廊、瓦夫尔、鲁汶到安特卫普的防线。在接下来的四个月里，荷兰和比利时的军队努力加强防御，英国远征军扩大了规模，法国军队接受了更多的装备和训练。甘末林还考虑向荷兰的布雷达进一步推进；假如盟军能够阻止德国占领荷兰，荷兰军队的十个师将加入盟军，盟军对北海的控制将得到加强，德国人则无法获得攻击英国的基地。\n1940年5月时，第1集团军群负责法国从海峡沿岸到马其诺防线西端的防御工作。乔治·莫里斯·让·布朗沙尔统率的法国第1集团军、亨利·吉罗统率的第7集团军、安德烈·乔治·科拉普统率的第9集团军和戈特勋爵统率的英国远征军准备从右翼（南侧）的法国第2集团军处转向，向迪尔河防推进。第7集团军将接管安特卫普以西，准备进入荷兰；而比利时人预期将推迟德国前进，然后沿阿尔伯特运河撤退至迪尔河，从安特卫普退至鲁汶。在比利时右翼，英国远征军将有9个师保卫迪尔河从鲁汶到瓦夫尔一段约20公里的防区。英国人右侧的法国第1集团军将以10个师守卫35公里长的防线，防区为从瓦夫尔到那慕尔的一段区域。这一段即为“让布卢走廊”，是位于桑布尔河以北从迪尔河到那慕尔的一段走廊区域，可以从马斯特里赫特经让布卢直通蒙斯，沿途几乎没有天然障碍，是进攻巴黎的传统入侵路线。法国第9集团军将驻扎于那慕尔以南，沿着默兹河到达第2集团军的左翼（北部）。\n法国第2集团军是第1集团军群的右翼（东侧）部队，驻守的防线从色当以西6公里的蓬塔巴尔到隆吉永。陆军总部认为第2集团军和第9集团军的任务是集团军群中最简单的，他们的防线一边是易于防守的默兹河西岸；另一边有着阿登地区作为屏障，如果德军试图穿越这一地区，等同于发出大量有关德国攻击法国前线中心的警告。在从第7集团军的战略预备队转移至第1集团军群后，有7个师驻守在第2集团军和第9集团军后方，更多的师可以从马奇诺防线后方调来。除了一个师之外，其他所有的师都驻扎在第2集团军和第9集团军的交界处两侧。陆军总部更担心德军从北部绕过马奇诺防线后沿斯特奈走廊向东南进攻，因此才如此部署后方的这几个师。\n参战军队和部署德国动员了420万陆军、100万空军、18万海军与10万党卫队。考虑到在波兰、丹麦和挪威的部队，1940年5月10日德国陆军约有300万人可以参加进攻。这300万人被组织为157个师，其中的135个师（包括42个预备队师）被指定用于进攻。5月到6月的德国西线部队部署了2,439辆坦克和7,378门火炮。1939年到1940年，德国陆军45%的成员年龄超过40岁，超过半数的士兵只经历过几周的训练。陆军远未实现全摩托化，在1940年只有10%的部队实现了摩托化，可供使用的车辆仅有12万辆；与之相比，法国陆军足有30万辆车辆，而英国的摩托化部队位于各国最前列。德军的大多数后勤运输使用马拉车辆。1940年德国可用的部队中，只有50%的师完成了战斗准备；装备状况往往比不过同等的英法部队，有的甚至不如1914年的德国陆军。总而言之，1940年的德国陆军是一支半现代化的部队，少数装备精良的“精锐师”被“大量二级和三级师抵消了”。\n德军部队被分为多个集团军群。A集团军群由格特·冯·伦德施泰特指挥，由45.5个师组成，其中包含7个装甲师。A集团军群将执行由阿登地区突破盟军防御的决定性机动。德军的这一机动有时被称作“镰刀切割”，最早被丘吉尔用来形容德军的行动，后来又被翻译回德语（Sichelschnitt），但从未成为行动的正式名称。“镰刀切割”涉及3个集团军，即国防军第4集团军、第12集团军和第16集团军；共拥有3个装甲军。第15军被分配给第4集团军，而莱因哈特指挥的第41装甲军和古德里安的第19装甲军与第14军的两个摩托化步兵师统一为一个特殊的独立作战单位——“克莱斯特装甲兵团”，官方番号为第22集团军。B集团军群由费多尔·冯·博克指挥，含29.5个师，其中有3个装甲师。B集团军群的目标是向低地国家进攻，将盟军的北部部队引诱入德军的圈套中。该集团军群包括国防军第6集团军和第18集团军。C集团军群由威廉·冯·里布指挥，下辖18个师。C集团军群的主要目的是防止盟军在东侧发起侧翼包围，并沿马奇诺防线和莱茵河上游持续发动小规模袭击。该集团军群包括国防军第1集团军群和第7集团军。\n“黄色方案”作战德军的“黄色方案”于1940年5月9日晚开始。21:00时，陆军的所有师都收到了行动开始的暗语“但泽”。作战行动的保密性很高，以至于当部队接到行动开始的命令时，许多军官由于持续的延误还没有赶到自己的部队。 德军在行动伊始占领了卢森堡，几乎未遭抵抗。B集团军群在9日夜间到10日早上发动了对荷兰和比利时的佯攻。第7空降猎兵师与库尔特·斯图登特的第22空降师空降猎兵突袭了荷兰海牙、通向鹿特丹的道路、以及比利时的埃本-埃美尔要塞，旨在协助B集团军群的推进。法军司令部立即做出反应，按照D计划将第1集团军群派遣至北方。这一机动投入了法军最好的部队，但引发了局部的组织混乱且耗尽了燃料储存，折损了部队的实力。等到法国第7集团军跨越荷兰边境时，他们发现荷兰军队正在全面撤退，正进入比利时保卫安特卫普。\n荷兰\n空降作战是荷兰战役的重要组成部分，德国空军在荷兰完全确保了制空权，德军飞机无论是数量还是品质都明显优于荷兰。德国空军出动了247架中型轰炸机、147架战斗机、424架容克Ju-52运输机及12架亨克尔He-59水上飞机参加在荷兰上空的行动。荷兰空军共有144架作战飞机，其中许多还是一战时期的老式飞机。仅在第一天的作战中，荷军就损失了约一半的战机，剩下的荷兰空军飞机被疏散至各地，只击落了少量德国空军飞机。荷兰空军总共只有332架次的飞行，共有110架飞机被击落。\n荷兰机场中一架烧毁了的德军Ju 52运输机。德国空军运输机在荷兰战役中损失将近半数德国空军先是通过空降兵对荷兰发动突袭，这次作战被称为海牙战役，由于低估了荷兰皇家陆军的抵抗而失利。空军以一场惨胜占领了海牙周边伊彭堡、奥肯堡和法尔肯堡的机场，但损失了大量运输机，而当天晚些时候荷兰军队就收复了机场。总共有96架飞机毁于荷兰的炮击。德国空降兵被赶出机场，压制在几个据点中，但荷兰军队的火力严重不足，无法将其消灭。德国空军的运输机群任务中有125架Ju-52被击毁，47架被击伤，损失相当于运输机群的一半；德军空降部队的4000人中将近半数在空降行动中损失，包括20%的士官和42%的军官；其中有1,200人被俘后送至英国。\n德国陆军在5月10日向荷兰边境发动突然进攻以策应空降兵，法国第7集团军群未能阻止德国第9装甲师的增援。德军攻势势如破竹，荷军难以抵挡。5月13日，第9装甲师抵达了鹿特丹；同一天，东方的荷兰陆军对德军的赫雷伯山战役反攻行动宣告失败，从赫雷伯防线撤退至新洪水线，这时荷兰的防线大举收缩，败局已定。5月14日，为了尽快拿下荷军坚守的荷兰要塞，空军进行了颇具争议的鹿特丹轰炸，德国第54轰炸机联队的He-111中型轰炸机炸毁了鹿特丹市中心。尽管荷兰军队主力尚存，但荷兰政府认为荷兰战役对于整体战略无关紧要，而且他们担心德军进一步摧毁其他荷兰城市，因此很快就打算停止抵抗。荷兰军方在轰炸发生后于当晚也宣布投降。5月15日双方签署了投降文书，但荷兰部分部队仍与法军在泽兰战役中并肩作战，直到5月17日荷兰全境沦陷，而荷兰殖民地的部队也继续战斗。威廉明娜女王在英国成立了荷兰流亡政府。荷兰损失为陆军2,157人、海军125人、空军75人，平民2,559人，荷兰的抵抗则给德军造成了2,032人死亡，7,000人受伤，4辆武装火车被摧毁，225–275架飞机被摧毁，1,350人被俘的损失。\n比利时\n德军在比利时掌握了制空权。得益于战前彻底的空中照相侦察，德军在入侵比利时的最初24小时内便击毁了比利时空军179架飞机中的83架。比利时空军共执行77次飞行作战任务，但对空战结果贡献不大。德军从此确保了低地国家上空的空中优势。然而在地面作战中，由于B集团军群的兵力比原先的计划有所削弱，而比利时军在阿尔伯特运河阵地的防卫非常强大，导致德国第6集团军的佯攻面临立即停滞的危险。德军的主要推进路线被默兹河和阿尔伯特运河交汇处的埃本-埃美尔要塞封锁。在当时，埃本-埃美尔要塞被认为是全欧洲最现代化的大型要塞。\n对德军而言，能否在A集团军群建立桥头堡之前将盟军大部引开是胜利的关键，因此任何的延宕都可能威胁整个战役的进展。为了克服这一困难，德国在埃本-埃美尔要塞战役中采取了非常手段。5月10日清晨，德军突击队搭乘DFS-230滑翔机降落在要塞屋顶，使用锥形装药瘫痪了主要炮台。德军伞兵占领了运河上的桥梁。比利时部队发起了相当程度的反击，但都被德国空军瓦解。德军从可能是防御最强点的位置突破了比利时防线，让比利时最高指挥部大为震惊。比利时指挥部随即将各师撤退至K-W防线，比原计划提前了5天。然而德军夺取荷兰马斯特里赫特桥梁的一场类似行动宣告失败：荷兰人炸毁了所有桥梁，德军只占领了一座铁路桥,导致装甲部队被迫在荷兰滞留一段时间。\n英国远征军和法国第1集团军尚未完成驻防，比利时在边境战败的消息是他们不愿听到的。盟军原本确信比利时的抵抗可以让部队有数周的时间准备让布卢走廊的防线。此时，埃里希·霍普纳上将正率领由第3装甲师和第4装甲师组成的德国第16装甲军跨越德军新占领的桥梁，向让布卢走廊方向进军。法军最高指挥部先前预计德军闪电战的攻击中心会在让布卢一带，而第16装甲军的行动似乎证实了这一看法。让布卢位于瓦夫尔和那慕尔之间，地势平坦，为坦克作战的理想地区；这一地段也是盟军防线上未设防御工事的一段。法国第1集团军骑兵军司令勒内·普利欧派遣第2轻机械化师和第3轻机械化师向让布卢以东的阿尼进军，拖延该地德军装甲部队的推进，为第1集团军的其它部队争取时间完成让布卢地区的防御。\n阿尼战役\n5月12日至13日发生的阿尼战役是截至当时规模最大的坦克战，双方共有1,500辆装甲战斗车辆参战。法军以损失91辆哈奇斯H35和30辆Somua-S35的代价，使160辆德军坦克瘫痪。但法军依照战役计划实施撤退，使得德军重新控制了战场，并得以修复先前瘫痪的坦克。德军最终无法修复的只有第3装甲师的20辆坦克及第4装甲师的29辆坦克。普利欧为法军取得了战术和战略胜利，成功将德军进军拖延至第1军团有足够时间修筑工事为止。进攻的德军在色当北部与法国第1军团交战，实现了霍普纳必须完成的最重要目标；但是德军未能阻止法军向迪尔河进军，也未能摧毁第1军团。5月14日，在阿尼遇阻的霍普纳违背军令，于让布卢战役再次发起攻击。这场战斗是整个法国战役中德军唯一一次正面攻击防御工事的场合。法国第1摩洛哥步兵师成功击退德军进攻，德国第4装甲师又有42辆坦克瘫痪，其中26辆被彻底击毁。然而法军两次成功的防守很快被色当南部的事态发展抵消了。\n","slug":"法国战役","date":"2024-10-15T10:19:13.000Z","categories_index":"","tags_index":"杂谈","author_index":"Math-zhuxy"},{"id":"25ed3aa3446c2c64cf6228f9f4e4f9c4","title":"DP","content":"简介DP是一个非常广泛的题目类型。比较难的DP题目一般都很抽象，很难提取出DP数组出来，这边文章也只是笼统的介绍一下DP，并介绍一个DP最经典最简单的例子。定义：动态规划（Dynamic Programming）：简称 DP，是一种求解多阶段决策过程最优化问题的方法。在动态规划中，通过把原问题分解为相对简单的子问题，先求解子问题，再由子问题的解而得到原问题的解。\n题目背包问题背包问题（Knapsack Problem）是一个经典的组合优化问题，通常用于决策与资源分配场景。其基本描述如下：\n在给定的物品集合中，每个物品都有其特定的重量和价值。背包问题的目标是在不超过背包最大承载重量的情况下，选择一组物品，使得所选物品的总价值最大化。\n背包问题的主要变种包括：\n\n0-1背包问题（0/1 Knapsack Problem）：每个物品只能选择一次，要么放入背包，要么不放入。\n\n完全背包问题（Complete Knapsack Problem）：每个物品可以选择多次，可以放入背包多次。\n\n分数背包问题（Fractional Knapsack Problem）：物品可以被分割，允许选择物品的一部分，通常用贪心算法解决。\n\n\n背包问题的数学模型\n目标函数：最大化\n\n约束条件：\n其中， 表示第  个物品的价值， 表示第  个物品的重量， 为二元变量，表示物品是否被选取（0 或 1）， 为背包的最大承载重量。\n\n\n完全背包问题的动态规划解法\n状态定义：定义一个一维数组 dp，其中  表示背包容量为  时可以获得的最大价值。\n\n状态转移方程：对于每一种物品  和每个可能的背包容量 ：其中， 表示将第  种物品加入背包后可以获得的价值，而  表示不选择该物品时的价值。\n\n初始化：表示当背包容量为 0 时的最大价值为 0。其他  的初始值设为 0。\n\n遍历顺序：对于每个物品 ，从  到  遍历背包容量 ，允许重复选择相同的物品。\n\n\n算法步骤\n初始化 dp 数组。\n对于每种物品 ，遍历背包容量  从  到 ，更新 。\n最终  即为最大承载重量为  时的最大价值。\n\n时间复杂度动态规划算法的时间复杂度为 ，其中  是物品的数量， 是背包的最大承载重量。\n示例代码12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int N=1010;int dp[N][N];int val[N];int w[N];int main(){    int n,v;    scanf(\"%d%d\",&amp;n,&amp;v);    for(int i=1;i&lt;=n;i++){        scanf(\"%d%d\",&amp;w[i],&amp;val[i]);    }    for(int i=1;i&lt;=n;i++){        for(int j=0;j&lt;=v;j++){            dp[i][j]=dp[i-1][j];            if(j&gt;=w[i])dp[i][j]=max(dp[i][j],dp[i-1][j-w[i]]+val[i]);        }    }    int res=0;    for(int i=0;i&lt;=v;i++){        res=max(res,dp[n][i]);    }    printf(\"%d\",res);    return 0;}\n\n小试牛刀题目描述你面临  名参赛者的挑战，最终要将他们全部战胜。每一轮中，都会淘汰一些选手；你会得到这一轮奖金池中 被淘汰者 除以 这一轮对手总数 比例的奖金。  \n例如某一轮有  个对手，淘汰了  个，那么你将获得奖金池中  的奖金。  \n假设每一轮的奖金池均为一元，Mirko 希望通过恰好  轮赢得比赛，那么他最多可能获得多少奖金呢？   \n你只需要输出答案保留  位小数即可。\n输入格式一行两个正整数 。\n输出格式输出一行一个实数表示答案。\n样例 #1样例输入 #115 3\n\n样例输出 #112.100000000\n\n样例 #2样例输入 #2110 10\n\n样例输出 #212.928968254\n\n提示样例1解释：最优的情况为：第一轮淘汰  人，剩下两轮各淘汰  人。获得奖金为  元。\n数据范围：对于的数据，。\n对于的数据，。\n对于的数据，。\n本题较卡精度，请留意。\n题解DP 公式与斜率优化定义\n设  为当前淘汰了  人，已经进行  轮的答案。\n状态转移方程\n显然有：其中：\n\n 为当前轮淘汰人数，\n 为当前轮总人数。\n\n斜率优化\n注意这里是求最大值：\n可以转化为：\n定义  和 \n令：\n优化后的不等式\n有：\n化简为：\n这个式子方便判断凸的方向。\nwqs 二分法先不考虑  轮的限制，显然可以直接计算。\n使用斜率为  的直线  去切由轮数为 1 到  的最优解组成的上凸包。\n切点与截距切点为 ，满足  轮的条件， 为  轮时的最优解。\n设：\n我们取到最大的 。\n注意到进行了  段，减去了 ，那么  相当于每段的贡献减  的答案。\n二分 最终答案为：\n因为有点卡精度，所以将除法移到右边变成乘法：\n队尾处理同理。\n代码1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define eps 1e-18using namespace std;long double f[100010];int q[100010],hd,tl;int s[100010],n,k;long double X(int i){\treturn 1.0/(long double)(n-i);}long double Y(int i){\treturn f[i]-(long double)i/(n-i);}bool check(long double mid){\thd=1,tl=0;\tq[++tl]=0;\tfor(int i=1;i&lt;=n;i++){\t\twhile(hd&lt;tl&amp;&amp;Y(q[hd+1])-Y(q[hd])&gt;=-i*(X(q[hd+1])-X(q[hd]))) hd++;\t\tint j=q[hd];\t\ts[i]=s[j]+1;\t\tf[i]=f[j]+(long double)(i-j)/(n-j)-mid;\t\twhile(hd&lt;tl&amp;&amp;(Y(q[tl])-Y(q[tl-1]))*(X(i)-X(q[tl-1]))&lt;=(Y(i)-Y(q[tl-1]))*(X(q[tl])-X(q[tl-1]))) tl--;\t\tq[++tl]=i;\t}\treturn s[n]&lt;=k;}int main(){\tscanf(\"%d%d\",&amp;n,&amp;k);\tlong double l=0,r=1,mid;\twhile(l&lt;r-eps){\t\tmid=(l+r)/2.0;\t\tif(check(mid)) r=mid;//被减的越多段数就越少\t\telse l=mid;\t}\tprintf(\"%.9Lf\",f[n]+mid*k);}","slug":"DP","date":"2024-10-15T10:12:39.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"53896b079468d4c41963b2300dea196e","title":"KMP","content":"KMP简介假设有两个字符串需要匹配，此时已经匹配到i，j位置：母串：str1 … str1 a(i) …字串：str1 (j’) … str1 b(j) …\n发现index位置a与b不相等，此时字串的匹配指针j不需要重新移到开始，i指针也不需要移动，j指针只要移动到j’位置即可\n因此我们只需要找到最长前后缀即可：以str&#x3D;”abcdefabc”为例\n注意：为了方便表示，我们让字符串下标从1开始\nne数组Next[i]&#x3D;j表示:str[1,j]&#x3D;str[i-j+1,i]以下图为例：Next[i]的方法：对于母串STR和字串str，假如母串从xi-1 ,子串从1j都是匹配的，此时匹配下一个位置：如果STR[i]&#x3D;&#x3D;str[j+1]，则i和j继续向后移动一位如果STR[i]!&#x3D;str[j+1]:注意到对于str来说，1到Next[j]段等于…到j段，而子串和母串的STR[…,i-1]与str[1,j]是相等的同时，根据Next数组定义：str[1,Next[j]]与str[…,j]是相等的，因此：STR[…,i-1]与str[1,Next[j]]部分是相等的，因此j指针可以移动到Next[j]，让i与Next[j]+1匹配因此i指针不用动，j指针可以退回到Next[j]以下图为例：匹配过程的代码：\n12345678//i从1开始遍历母串所有的字符，j从0开始(因为STR[i]与str[j+1]匹配的)for(int i = 1, j = 0; i &lt;= m; i ++)&#123;    //如果s[i]与s[j+1]不匹配，一直移动到无前后缀相等或者匹配为止    while(j &amp;&amp; s[i] != s[j+1])j=Next[j];    //如果是匹配成功的情况，j和i可以往下一位走了    if(s[i] == s[j+1])j++;    if(j == n)printf(&quot;ok&quot;);//已经移动到子串的末尾了，匹配成功&#125;\n接下来即是如何求解Next[i]:Next[i]的求解过程其实和字符串的匹配过程很相似首先Next[1]&#x3D;0，第一个字母匹配失败了，只能从0开始了。对于每个i假如str[i]与str[j+1]不匹配，即前后缀不等，那么j往前移动到Next[j]处继续匹配。其实就是自己和自己匹配的过程：\n123456for(int i = 2, j = 0; i &lt;= m; i ++)&#123;    while(j &amp;&amp; s[i] != s[j+1])j=Next[j];    if(s[i] == s[j+1])j++;    //将最后的结果存入Next[i]中    Next[i]=j;&#125;\n题目及解答给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉数字。\n模式串 P在字符串 S中多次作为子串出现。\n求出模式串 P在字符串 S中所有出现的位置的起始下标。代码：\n12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int n, m;const int N = 100010, M = 1000010;char p[N], s[M];int ne[N];int main() &#123;\tcin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;\tfor (int i = 2, j = 0; i &lt;= n; i++) &#123;\t\twhile (j &amp;&amp; p[i] != p[j + 1])j = ne[j];\t\tif (p[i] == p[j + 1])j++;\t\tne[i] = j;\t&#125;\tfor (int i = 1, j = 0; i &lt;= m; i++) &#123;\t\twhile (j &amp;&amp; s[i] != p[j + 1])j = ne[j];\t\tif (s[i] == p[j + 1])j++;\t\tif (j == n)&#123;\t\t    printf(&quot;%d &quot;, i - n);\t\t    j=ne[j];\t\t&#125;\t&#125;&#125;\n优化其实next数组还是可以进一步优化，举个例子：假设字符a的下标为i，其next值为next[i]，假设str[i]&#x3D;&#x3D;str[next[i]]，则不妨发现：当str在j+1处的与STR不的i处匹配，则str的j将跳到next[j]处，但此时next[j]与j处是相等的，因此这个匹配其实是没有必要的，可以直接移到next[next[i]]处，如此循环。我们用nextval数组储存这个最终的移动结果，表示：如果j处不匹配，则直接移动到nextval[j]处。求nextval方法：\n123456for(int i=1;i&lt;=n;i++)&#123;\t//如果相等，直接移动到next[i]的nextval处。\tif(str[i]==str[next[i]])nextval[i]=nextval[next[i]];\t//如果不相等，不需要多次移\telse nextval[i]=next[i];&#125;","slug":"KMP","date":"2024-10-14T02:54:06.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"cdfc7cbbb7cbed062094116ffd80f917","title":"DFS","content":"DFS简介DFS通常指的是深度优先搜索（Depth-First Search），它是一种用于遍历或搜索树或图的算法。在树中，DFS从根开始（选择某些节点作为根，在图形理论中不是必须的），先深入子分支，直到无法深入为止，然后回溯。这个过程会使用一个栈（可以是显式的或者递归函数的调用栈）来记录访问路径。以下是DFS的基本步骤：\n\n访问初始节点。\n对于当前节点的每一个尚未访问过的邻接节点，递归地执行DFS。\n当没有剩余节点时，则回溯。基本框架如下：1234567891011121314151617#include&lt;iostream&gt;using namespace stdvoid dfs(Node a){    if(a==NULL)return;    //标记该节点为已用    a.used=true;    //a节点处理    if(check(a)){        printf(\"get answer\");        return;    }    //遍历该节点的其他相邻节点    dfs(a.next_1);    dfs(a.next_2);    //...    //回溯，标记该节点为未用状态    a.used=false;\n\n为什么要回溯以上面的代码为例，如果代码已经运行到a.used=false;这一行，代表前面的dfs(a.next_1);dfs(a.next_2);都没有找到结果，证明走到a节点其实是找不到结果的，因此需要回退会a节点的父节点继续寻找，此时要标记a节点为为使用状态。\nDFS遍历顺序假设有一棵树结构如下：以上面的代码为例，假设L点满足我们的要求遍历路径如下：A-&gt;B-&gt;E-&gt;J-&gt;回溯(E)-&gt;回溯(B)-&gt;B-&gt;F-&gt;回溯(A)-&gt;C-&gt;G-&gt;K-&gt;回溯(G)-&gt;G-&gt;L-&gt;符合答案，输出下面给出几道常见的DFS题目：\nN皇后问题皇后问题是指将 n个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。现在给定整数N ，请你输出所有的满足条件的棋子摆法。代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;bool Arr[20][20];int n;int DirX[4]={1,1,-1,-1};int DirY[4]={1,-1,1,-1};bool IsOk(int x,int y){    for(int i=1;i&lt;=n;i++){        if(Arr[i][y])return false;    }    int k,q;    for(int i=0;i&lt;4;i++){        k=x;        q=y;        while(k&gt;=1&amp;&amp;k&lt;=n&amp;&amp;q&gt;=1&amp;&amp;q&lt;=n){            if(Arr[k][q])return false;            k+=DirX[i];            q+=DirY[i];        }    }    return true;}void dfs(int num){    if(num&gt;n){        for(int i=1;i&lt;num;i++){            for(int j=1;j&lt;num;j++){                if(Arr[i][j])printf(\"Q\");                else printf(\".\");            }            printf(\"\\n\");        }        printf(\"\\n\");        return;    }    for(int j=1;j&lt;=n;j++){        if(IsOk(num,j)){            Arr[num][j]=true;            dfs(num+1);            Arr[num][j]=false;        }    }}int main(){    scanf(\"%d\", &amp;n);    dfs(1);}\n小试牛刀题目描述这些天，兔兔和蛋蛋喜欢上了一种新的棋类游戏。\n这个游戏是在一个  行  列的棋盘上进行的。游戏开始之前，棋盘上有一个格子是空的，其它的格子中都放置了一枚棋子，棋子或者是黑色，或者是白色。\n每一局游戏总是兔兔先操作，之后双方轮流操作，具体操作为：\n\n兔兔每次操作时，选择一枚与空格相邻的白色棋子，将它移进空格。\n蛋蛋每次操作时，选择一枚与空格相邻的黑色棋子，将它移进空格。\n\n第一个不能按照规则操作的人输掉游戏。为了描述方便，下面将操作“将第x行第y列中的棋子移进空格中”记为 。\n例如下面是三个游戏的例子。\n\n\n\n最近兔兔总是输掉游戏，而且蛋蛋格外嚣张，于是兔兔想请她的好朋友——你——来帮助她。她带来了一局输给蛋蛋的游戏的实录，请你指出这一局游戏中所有她“犯错误”的地方。\n注意：\n\n两个格子相邻当且仅当它们有一条公共边。\n兔兔的操作是“犯错误”的，当且仅当，在这次操作前兔兔有必胜策略，而这次操作后蛋蛋有必胜策略。\n\n输入格式输入的第一行包含两个正整数 。\n接下来  行描述初始棋盘。其中第  行包含  个字符，每个字符都是大写英文字母 X、大写英文字母 O 或点号 . 之一，分别表示对应的棋盘格中有黑色棋子、有白色棋子和没有棋子。其中点号 . 恰好出现一次。\n接下来一行包含一个整数 （） ，表示兔兔和蛋蛋各进行了  次操作。\n接下来  行描述一局游戏的过程。其中第  行是兔兔的第  次操作（编号为  的操作） ，第  行是蛋蛋的第  次操作。每个操作使用两个整数  来描述，表示将第  行第  列中的棋子移进空格中。\n输入保证整个棋盘中只有一个格子没有棋子， 游戏过程中兔兔和蛋蛋的每个操作都是合法的，且最后蛋蛋获胜。\n输出格式输出文件的第一行包含一个整数 ，表示兔兔犯错误的总次数。\n接下来  行按递增的顺序给出兔兔“犯错误”的操作编号。其中第  行包含一个整数  表示兔兔第  个犯错误的操作是他在游戏中的第  次操作。\n样例 #1样例输入 #1123451 6 XO.OXO 1 1 2 1 1\n\n样例输出 #11211\n\n样例 #2样例输入 #2123456789101112133 3 XOX O.O XOX 4 2 3 1 3 1 2 1 1 2 1 3 1 3 2 3 3\n\n样例输出 #210\n\n样例 #3样例输入 #3123456789104 4 OOXX OXXO OO.O XXXO 2 3 2 2 2 1 2 1 3\n\n样例输出 #3123212\n\n提示对于  的数据，，，。\n\n\n\n测试点编号\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n题解前置知识对于二分图博弈，先手如果率先落入最大匹配的点x中，那么后手只需要选择与x匹配的点y走即可，走到最后先手必败；如果是完全匹配，那么先手无论落子何处，均率先落入最大匹配点，先手必败；如果不是完全匹配，先手选择非最大匹配点x落子，那么后手无论落子何处，都是最大匹配中的某点y， 因为如果y不是最大匹配的点, 则x到y形成增广路，最大匹配的边数还可以加1，导致矛盾；进而， 后手率先落入最大匹配的点中，先手有必胜策略；\n本题策略\n把棋子的移动视为空格的移动，那么兔兔先手移动空格到白子处，因此可以将空格看作黑色， 黑白染色，建二分图；如果在移动空格前，空格处于最大匹配的非必须点，那么移动后必然率先进入最大匹配中，必败，反之有必胜策略；\n对于K轮游戏，第i轮游戏时空格的位置cur在(sx, sy), 如果cur不在最大匹配中，那么落子后必落入最大匹配， 所以无论怎么落子，必败；\n如果cur在最大匹配中,且有匹配match[cur]为nxt，那么删掉cur后从nxt跑匈牙利算法（用于计算最小生成树），看nxt是否还能有另外的匹配，如果有 那么cur就不是最大匹配的必须点，有必胜策略，反之仍然必败；对每1轮游戏重复操作，得到每1轮游戏的胜负情况win[i]；\n如何判断兔兔犯了错误？——如果win[i]是必胜，而兔兔走完之后win[i+1]必胜，那么就说明兔兔犯了错；\n\n代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 50, K = 1005;int n, m, ans, cnt, tot, head[N*N];char g[N][N];int match[N*N], res[K*2], win[K*2]; bool vis[N*N], block[N*N], color[N][N];int dx[4] = {1, 0, 0, -1};int dy[4] = {0, 1, -1, 0};struct node {    int to, nxt;}edge[N*N*2*4]; //每个点连4个方向，双向边 void addedge(int s, int e) {    cnt++;    edge[cnt].to = e;    edge[cnt].nxt = head[s];    head[s] = cnt;    return ;}bool dfs(int x) //匈牙利算法{    for(int i = head[x]; i != 0; i = edge[i].nxt) \t{        int y = edge[i].to;        if(block[y] == true) //添加一行屏蔽已删掉的点         \tcontinue;        if(vis[y] == false) \t\t{            vis[y] = true;\t\t\t//如果y没有匹配 或者 y的匹配点match[y]能找到一个新的匹配            if(match[y] == 0 || dfs(match[y]) == true) \t\t\t{                match[y] = x; //y的配对点是x                match[x] = y; //增加这行代码的原因是为了找最大匹配非必须点                return true;            }        }    }    return false;}int get_id(int x, int y){\treturn (x-1) * m + y;} bool check(int x, int y){\tif(x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m || color[x][y] == false)\t\treturn false;\treturn true;\t}int main(){\t//输入 \tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= n; i++)        for(int j = 1; j &lt;= m; j++)\t\t\tcin &gt;&gt; g[i][j]; //迷宫数组 \t//染色\tint sx, sy;    for(int i = 1; i &lt;= n; i++)        for(int j = 1; j &lt;= m; j++)        {        \tif(g[i][j] == 'O') //将白色的棋子染色         \t{        \t\tcolor[i][j] = true;        \t}        \telse if(g[i][j] == '.') //起点记录，当作黑色对待         \t{        \t\tsx = i;        \t\tsy = j;\t\t\t}\t\t}    //建图     for(int i = 1; i &lt;= n; i++)        for(int j = 1; j &lt;= m; j++)        {        \tif(color[i][j] == true) //白子跳过         \t\tcontinue;        \tint cur = get_id(i, j); //当前点编号         \tfor(int k = 0; k &lt; 4; k++)        \t{        \t\tint nx = i + dx[k];        \t\tint ny = j + dy[k];        \t\tif(check(nx, ny) == false)        \t\t\tcontinue;        \t\tint nxt = get_id(nx, ny);        \t\taddedge(cur, nxt); //建边         \t\taddedge(nxt, cur); //找最大匹配不需要反边，但是找最大匹配非必须点需要折返跑 \t\t\t}\t\t}\t//匈牙利, 目的是看起点是否落在最大匹配中     for(int i = 1; i &lt;= n; i++)        for(int j = 1; j &lt;= m; j++)        {        \tif(color[i][j] == false)        \t\tcontinue;        \tmemset(vis, 0, sizeof(vis));        \tint cur = get_id(i, j);         \tif(dfs(cur) == true) \t\t\t\tans++;\t\t}\t//输入游戏过程 \tint k; \tcin &gt;&gt; k;\tfor(int i = 1; i &lt;= 2*k; i++)\t{\t\tint cur = get_id(sx, sy);\t\tblock[cur] = true; //删掉cur \t\tif(match[cur] == 0) //棋子当前不在匹配中，那么下一步会率先走到最大匹配中，必败 \t\t\twin[i] = false;\t\telse\t\t{\t\t\tint nxt =  match[cur];\t\t\tmatch[cur] = match[nxt] = 0;  //删掉cur与 nxt的匹配关系 \t\t\tmemset(vis, 0, sizeof(vis)); //跑匈牙利记得清0 vis \t\t\tif(dfs(nxt) == true) //若nxt还能找到匹配，则cur不是最大匹配必须, 那么下一步率先走到最大匹配，必败 \t\t\t\twin[i] = false;\t\t\telse\t\t\t\twin[i] = true; \t\t}\t\tcin &gt;&gt; sx &gt;&gt; sy;\t}\t\t//处理输出     for(int i = 1; i &lt;= k; i++)     {    \tif(win[2*i-1] == true &amp;&amp; win[2*i] == true) //兔兔走之前是有必胜策略，走完蛋蛋有必胜策略     \t{    \t\tres[++tot] = i; \t\t}\t}\tcout &lt;&lt; tot &lt;&lt; endl;\tfor(int i = 1; i &lt;= tot; i++)\t{\t\tcout &lt;&lt; res[i] &lt;&lt; endl;\t}    return 0;}","slug":"DFS","date":"2024-10-12T04:56:45.000Z","categories_index":"","tags_index":"算法","author_index":"Math-zhuxy"},{"id":"07311a8ec5a05f13261d3a44658af323","title":"欢迎","content":"网站简介这是我自己做的一个博客网站。博客框架是hexo，用来github提供的域名。目前没想好写什么东西，大概会写一些算法教程之类的东西，也许会写一些杂谈之类的。因为是部署在github静态网站服务上的，需要挂梯子才能打开，国内不稳定。\n","slug":"welcome","date":"2024-10-12T03:00:46.000Z","categories_index":"","tags_index":"网站简介","author_index":"Math-zhuxy"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-10-12T02:36:20.905Z","categories_index":"","tags_index":"","author_index":"Math-zhuxy"}]