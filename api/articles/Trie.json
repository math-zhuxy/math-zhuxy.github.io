{"title":"Trie","uid":"f9c5a67ed89813cc4d2fda9f690375dd","slug":"Trie","date":"2024-10-17T08:21:29.000Z","updated":"2024-11-20T11:02:41.318Z","comments":true,"path":"api/articles/Trie.json","keywords":null,"cover":[],"content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>为什么链表，Trie树和堆会用到idx来维护这个数据结构，而栈和队列就不用idx来维护，而是用hh和tt来维护呢？</p>\n<h1 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h1><p>可以看出不管是链表，Trie树还是堆，他们的基本单元都是一个个结点连接构成的，可以成为“链”式结构。这个结点包含两个基本的属性：本身的值和指向下一个结点的指针。按道理，应该按照结构体的方式来实现这些数据结构的，但是做算法题一般用数组模拟，主要是因为比较快。各个节点之间用idx联系起来。idx的操作总是idx++，这就保证了不同的idx值对应不同的结点，这样就可以利用idx把结构体内两个属性联系在一起了。因此，idx可以理解为结点。</p>\n<h2 id=\"链表：\"><a href=\"#链表：\" class=\"headerlink\" title=\"链表：\"></a>链表：</h2><p>链表中会使用到这几个数组来模拟：</p>\n<p>&#x2F;&#x2F; head存储链表头指向的节点，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点<br>h, e[N], ne[N], idx;<br>h表示头结点指针，一开始初始化指向-1，每次插入x的操作idx++。利用idx联系结构体本身的值和next指针，因此e[idx]可以作为结点的值，ne[idx]可以作为next指针。同理可以理解双链表。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_to_head</span> <span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] =  x;</span><br><span class=\"line\">    ne[idx] = h;</span><br><span class=\"line\">    h = idx ++ ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//双链表</span></span><br><span class=\"line\"><span class=\"comment\">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> a,  <span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = x;</span><br><span class=\"line\"></span><br><span class=\"line\">    l[idx] = a;</span><br><span class=\"line\">    r[idx] = r[a];</span><br><span class=\"line\"></span><br><span class=\"line\">    l[r[a]] = idx;</span><br><span class=\"line\">    r[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```C++</span><br><span class=\"line\">Trie树</span><br><span class=\"line\">Trie树中有个二维数组 son[N][<span class=\"number\">26</span>]，表示当前结点的儿子，如果没有的话，可以等于++idx。Trie树本质上是一颗多叉树，对于字母而言最多有<span class=\"number\">26</span>个子结点。所以这个数组包含了两条信息。比如：son[<span class=\"number\">1</span>][<span class=\"number\">0</span>]=<span class=\"number\">2</span>表示<span class=\"number\">1</span>结点的一个值为a的子结点为结点<span class=\"number\">2</span>;如果son[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>，则意味着没有值为a子结点。这里的son[N][<span class=\"number\">26</span>]相当于链表中的ne[N]。</span><br><span class=\"line\">```C++</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"built_in\">insert</span>(<span class=\"type\">char</span> str[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> p = <span class=\"number\">0</span>; <span class=\"comment\">//从根结点开始遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; str[i]; i ++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u =str[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!son[p][u]) son[p][u] = ++ idx; <span class=\"comment\">//没有该子结点就创建一个</span></span><br><span class=\"line\">        p = son[p][u]; <span class=\"comment\">//走到p的子结点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cnt[p] ++; <span class=\"comment\">// cnt相当于链表中的e[idx]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>堆<br>堆中的每次插入都是在堆尾，但是堆中经常有up和down操作。所以结点与结点的关系并不是用一个ne[idx][2]可以很好地维护的。但是好在堆是个完全二叉树。子父节点的关系可以通过下标来联系（左儿子2n，右儿子2n+1）。就数组模拟来说，知道数组的下标就知道结点在堆中的位置。所以核心就在于即使有down和up操作也能维护堆数组的下标（k）和结点（idx）的映射关系。 比如说：h[k] &#x3D; x, h数组存的是结点的值，按理来说应该h[idx]来存，但是结点位置总是在变的，因此维护k和idx的映射关系就好啦，比如说用ph数组来表示ph[idx] &#x3D; k, 那么结点值为h[ph[idx]], 儿子为ph[idx] * 2和ph[idx] * 2 + 1, 这样值和儿子结点不就可以通过idx联系在一起了吗？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (op == <span class=\"string\">&quot;I&quot;</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    size ++ ;</span><br><span class=\"line\">    idx ++ ;</span><br><span class=\"line\">    ph[idx] = size, hp[size] = idx;<span class=\"comment\">//每次插入都是在堆尾插入</span></span><br><span class=\"line\">    h[size] = x;<span class=\"comment\">//h[k], k是堆数组的下标，h存储的是结点的值，也就是链表中的e[idx]</span></span><br><span class=\"line\">    <span class=\"built_in\">up</span>(size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于idx只有在插入的时候才会更新为idx ++，自然idx也表示第idx插入的元素。</p>\n<h1 id=\"Trie树\"><a href=\"#Trie树\" class=\"headerlink\" title=\"Trie树\"></a>Trie树</h1><p>用来快速存储字符串集合的树（字母类型不会很多）。<br>集合的数据结构。<br>字符串：<br>abcdef<br>abdef<br>aced<br>bcdc<br><img src=\"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1729762660880375346_%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20173711.png\"><br>具体代码实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> son[N][<span class=\"number\">26</span>],cnt[N],idx;</span><br><span class=\"line\"><span class=\"comment\">//idx=0表示根节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> str[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> p=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//str[i]如果为&#x27;\\0&#x27;表示字符串尾</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; str[i]; i ++ )&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u=str[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(son[p][u]==<span class=\"number\">0</span>)son[p][u]=++idx;</span><br><span class=\"line\">        p=son[p][u];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cnt[p]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">char</span> str[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> p=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;str[i];i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u=str[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(son[p][u]==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        p=son[p][u];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cnt[p];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h1><p>最大异或和：给定 $N$ 个整数， $A_1,A_2,…A_N$ ，从当中任意挑两个整数，问最大的异或值是多少。<br>假设 $A_i&#x3D;10010…1$ 我们先看最高位，如果有一个 $A_j$ 它的最高位是0，那么它的异或结果将比较大，对这些 $A_j$ 组成的集合再进行筛查：看第二高位与 $A_i$ 是否不一样，依次类推…</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">100010</span>,M=<span class=\"number\">3000000</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> arr[N];</span><br><span class=\"line\"><span class=\"type\">int</span> son[M][<span class=\"number\">2</span>],idx;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> p=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">30</span>; ~i; i--)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>&amp; s=son[p][x&gt;&gt;i &amp; <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!s)s=++idx;</span><br><span class=\"line\">        p=s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"number\">0</span>,p=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i= <span class=\"number\">30</span>; ~i;i--)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> s=x&gt;&gt;i&amp;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(son[p][!s])&#123;</span><br><span class=\"line\">            res+=<span class=\"number\">1</span>&lt;&lt;i;</span><br><span class=\"line\">            p=son[p][!s];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> p=son[p][s];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class=\"line\">        <span class=\"built_in\">insert</span>(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)res=<span class=\"built_in\">max</span>(res,<span class=\"built_in\">query</span>(arr[i]));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,res);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","text":"问题为什么链表，Trie树和堆会用到idx来维护这个数据结构，而栈和队列就不用idx来维护，而是用hh和tt来维护呢？ 解答可以看出不管是链表，Trie树还是堆...","permalink":"/post/Trie","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":14,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E7%AD%94\"><span class=\"toc-text\">解答</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%EF%BC%9A\"><span class=\"toc-text\">链表：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Trie%E6%A0%91\"><span class=\"toc-text\">Trie树</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">例题</span></a></li></ol>","author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Dijkstra","uid":"7ff27b21dc778d80ff5e8e51d9209bee","slug":"Dijkstra","date":"2024-10-17T08:21:57.000Z","updated":"2024-10-17T10:51:06.900Z","comments":true,"path":"api/articles/Dijkstra.json","keywords":null,"cover":[],"text":"介绍迪杰斯特拉算法采用的是一种贪心的策略。 求源点到其余各点的最短距离步骤如下： 用一个 dist 数组保存源点到其余各个节点的距离，dist[i] 表示源点到...","permalink":"/post/Dijkstra","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":14,"path":"api/tags/算法.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"BFS","uid":"750466a07204eea158a8ccd364ba109b","slug":"BFS","date":"2024-10-17T08:20:47.000Z","updated":"2024-10-18T08:01:31.029Z","comments":true,"path":"api/articles/BFS.json","keywords":null,"cover":[],"text":"简介BFS其实和DFS很像，也是一种树的遍历，只不过BFS每次都会先把某一深度的节点全部遍历完再搜索下一个深度的节点。思路从起点开始，往前走第一步，记录下所有第...","permalink":"/post/BFS","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":14,"path":"api/tags/算法.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}