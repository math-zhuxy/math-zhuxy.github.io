{"title":"Dijkstra","uid":"7ff27b21dc778d80ff5e8e51d9209bee","slug":"Dijkstra","date":"2024-10-17T08:21:57.000Z","updated":"2024-10-17T10:51:06.900Z","comments":true,"path":"api/articles/Dijkstra.json","keywords":null,"cover":[],"content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>迪杰斯特拉算法采用的是一种贪心的策略。</p>\n<p>求源点到其余各点的最短距离步骤如下：</p>\n<ol>\n<li><p>用一个 dist 数组保存源点到其余各个节点的距离，dist[i] 表示源点到节点 i 的距离。初始时，dist 数组的各个元素为无穷大。<br>用一个状态数组 state 记录是否找到了源点到该节点的最短距离，state[i] 如果为真，则表示找到了源点到节点 i 的最短距离，state[i] 如果为假，则表示源点到节点 i 的最短距离还没有找到。初始时，state 各个元素为假。<br><img src=\"https://cdn.acwing.com/media/article/image/2021/03/04/55289_0783d4c47c-03.png\"></p>\n</li>\n<li><p>源点到源点的距离是0.即 dist[i]&#x3D;0<br><img src=\"https://cdn.acwing.com/media/article/image/2021/03/04/55289_4afe05d47c-04.png\"></p>\n</li>\n<li><p>遍历 dist 数组，找到一个节点，这个节点是：没有确定最短路径的节点中距离源点最近的点。假设该节点编号为 i。此时就找到了源点到该节点的最短距离，state[i] 设为 1。<br><img src=\"https://cdn.acwing.com/media/article/image/2021/03/04/55289_5338a3607c-05.png\"></p>\n</li>\n<li><p>遍历 i 所有可以到达的节点 j，如果 dist[j] 大于 dist[i] 加上 i -&gt; j 的距离，即<br>$$<br>dist[j] &gt; dist[i] + w[i][j]（w[i][j] 为 i -&gt; j 的距离）$$ ，则更新 dist[j] &#x3D; dist[i] + w[i][j]。<br><img src=\"https://cdn.acwing.com/media/article/image/2021/03/04/55289_58bec3b67c-06.png\"></p>\n</li>\n<li><p>重复 3 4 步骤，直到所有节点的状态都被置为 1。<br><img src=\"https://cdn.acwing.com/media/article/image/2021/03/04/55289_5fcd522c7c-071.png\"></p>\n</li>\n<li><p>此时 dist 数组中，就保存了源点到其余各个节点的最短距离。<br><img src=\"https://cdn.acwing.com/media/article/image/2021/03/04/55289_92893d427c-13.png\"></p>\n</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">510</span>, M = <span class=\"number\">100010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> h[N], e[M], ne[M], w[M], idx;<span class=\"comment\">//邻接表存储图</span></span><br><span class=\"line\"><span class=\"type\">int</span> state[N];<span class=\"comment\">//state 记录是否找到了源点到该节点的最短距离</span></span><br><span class=\"line\"><span class=\"type\">int</span> dist[N];<span class=\"comment\">//dist 数组保存源点到其余各个节点的距离</span></span><br><span class=\"line\"><span class=\"type\">int</span> n, m;<span class=\"comment\">//图的节点个数和边数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c)</span><span class=\"comment\">//插入边</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Dijkstra</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\">sizeof</span>(dist));<span class=\"comment\">//dist 数组的各个元素为无穷大</span></span><br><span class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;<span class=\"comment\">//源点到源点的距离为置为 0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)<span class=\"comment\">//遍历 dist 数组，找到没有确定最短路径的节点中距离源点最近的点t</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!state[j] &amp;&amp; (t == <span class=\"number\">-1</span> || dist[j] &lt; dist[t]))</span><br><span class=\"line\">                t = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        state[t] = <span class=\"number\">1</span>;<span class=\"comment\">//state[i] 置为 1。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = h[t]; j != <span class=\"number\">-1</span>; j = ne[j])<span class=\"comment\">//遍历 t 所有可以到达的节点 i</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> i = e[j];</span><br><span class=\"line\">            dist[i] = <span class=\"built_in\">min</span>(dist[i], dist[t] + w[j]);<span class=\"comment\">//更新 dist[j]</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"built_in\">sizeof</span>(h));<span class=\"comment\">//邻接表初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (m--)<span class=\"comment\">//读入 m 条边</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a, b, w;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(a, b, w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Dijkstra</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dist[n] != <span class=\"number\">0x3f3f3f3f</span>)<span class=\"comment\">//如果dist[n]被更新了，则存在路径</span></span><br><span class=\"line\">        cout &lt;&lt; dist[n];</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","text":"介绍迪杰斯特拉算法采用的是一种贪心的策略。 求源点到其余各点的最短距离步骤如下： 用一个 dist 数组保存源点到其余各个节点的距离，dist[i] 表示源点到...","permalink":"/post/Dijkstra","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":10,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">介绍</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">代码</span></a></li></ol>","author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"spfa","uid":"b15a3d80cccdf73982f5b8a5b568cf91","slug":"spfa","date":"2024-10-17T08:22:06.000Z","updated":"2024-10-18T10:05:15.879Z","comments":true,"path":"api/articles/spfa.json","keywords":null,"cover":null,"text":"分析SPFA算法仅仅只是Bellman_ford算法的一个优化。Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那...","permalink":"/post/spfa","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":10,"path":"api/tags/算法.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Trie","uid":"f9c5a67ed89813cc4d2fda9f690375dd","slug":"Trie","date":"2024-10-17T08:21:29.000Z","updated":"2024-10-25T12:23:46.858Z","comments":true,"path":"api/articles/Trie.json","keywords":null,"cover":[],"text":"问题为什么链表，Trie树和堆会用到idx来维护这个数据结构，而栈和队列就不用idx来维护，而是用hh和tt来维护呢？ 解答可以看出不管是链表，Trie树还是堆...","permalink":"/post/Trie","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":10,"path":"api/tags/算法.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}