{"title":"哈夫曼树","uid":"fa96493f1be9ea4e62c8ce720d007a3f","slug":"哈夫曼树","date":"2024-11-16T06:48:22.000Z","updated":"2024-11-16T07:08:32.332Z","comments":true,"path":"api/articles/哈夫曼树.json","keywords":null,"cover":null,"content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><ol>\n<li><p>路径:从树中一个结点到另一个结点之间的分支构成这两个结点间的路径。</p>\n</li>\n<li><p>结点的路径长度:两结点间路径上的分支数。</p>\n</li>\n<li><p>树的路径长度：从树根到每一个结点的路径长度之和。</p>\n</li>\n<li><p>权(又称权重)：将树中结点赋给一个有着某种含义的数值，(具体的意义根据树使用的场合确定)则这个数值称为该结点的权。</p>\n</li>\n<li><p>结点的带权路径长度：从根结点到该结点之间的路径长度与结点上权的乘积</p>\n</li>\n<li><p>树的带权路径长度:树中所有叶子结点的带权路径长度之和。</p>\n</li>\n<li><p>树的路径长度:从树根到每一个结点的路径长度之和。</p>\n</li>\n<li><p>“带权路径长度最短”是在“度相同”的树中比较而得的结果,因此有最优二叉树、最优三叉树之称。</p>\n</li>\n</ol>\n<p>哈夫曼树定义:最优二叉树，带权路径长度(WPL)最短的二叉树，因为构造这种树的算法是由哈夫曼教授于1952年提出的,所以被称为哈夫曼树,相应的算法称为哈夫曼算法。</p>\n<h1 id=\"哈夫曼树构造算法\"><a href=\"#哈夫曼树构造算法\" class=\"headerlink\" title=\"哈夫曼树构造算法\"></a>哈夫曼树构造算法</h1><p>哈夫曼算法<br>(1)根据n个给定的权值$(W_1,W_2,…, W_n)$构成$n$棵二叉树的森林$F&#x3D;(T_1, T_2,.., T_n)$,其中T_i只有一个带权为W_i的根结点。</p>\n<p>(2)在$F$中选取两棵根结点的权值最小的树作为左右子树,构造一棵新的二叉树,且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</p>\n<p>(3)在$F$中删除这两棵树,同时将新得到的二叉树加入森林中。</p>\n<p>(4)重复(2)和(3),直到森林中只有一棵树为止,这棵树即为哈夫曼树。</p>\n<h1 id=\"哈夫曼算法代码实现\"><a href=\"#哈夫曼算法代码实现\" class=\"headerlink\" title=\"哈夫曼算法代码实现\"></a>哈夫曼算法代码实现</h1><h2 id=\"哈弗曼树中结点结构\"><a href=\"#哈弗曼树中结点结构\" class=\"headerlink\" title=\"哈弗曼树中结点结构\"></a>哈弗曼树中结点结构</h2><p>构建哈夫曼树时，首先需要确定树中结点的构成。<br>由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//哈夫曼树结点结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> weight;<span class=\"comment\">//结点权重</span></span><br><span class=\"line\">    <span class=\"type\">int</span> parent, left, right;<span class=\"comment\">//父结点、左孩子、右孩子在数组中的位置下标</span></span><br><span class=\"line\">&#125;HTNode, *HuffmanTree;</span><br></pre></td></tr></table></figure>\n<h2 id=\"哈弗曼树中的查找算法\"><a href=\"#哈弗曼树中的查找算法\" class=\"headerlink\" title=\"哈弗曼树中的查找算法\"></a>哈弗曼树中的查找算法</h2><p>构建哈夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。</p>\n<p>查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：</p>\n<p>如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；<br>如果介于两个结点权重值之间，替换原来较大的结点；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//HT数组中存放的哈夫曼树，end表示HT数组中存放结点的最终位置，s1和s2传递的是HT数组中权重值最小的两个结点在数组中的位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Select</span><span class=\"params\">(HuffmanTree HT, <span class=\"type\">int</span> end, <span class=\"type\">int</span> *s1, <span class=\"type\">int</span> *s2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> min1, min2;</span><br><span class=\"line\">    <span class=\"comment\">//遍历数组初始下标为 1</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//找到还没构建树的结点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(HT[i].parent != <span class=\"number\">0</span> &amp;&amp; i &lt;= end)&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    min1 = HT[i].weight;</span><br><span class=\"line\">    *s1 = i;</span><br><span class=\"line\">   </span><br><span class=\"line\">    i++;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(HT[i].parent != <span class=\"number\">0</span> &amp;&amp; i &lt;= end)&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//对找到的两个结点比较大小，min2为大的，min1为小的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(HT[i].weight &lt; min1)&#123;</span><br><span class=\"line\">        min2 = min1;</span><br><span class=\"line\">        *s2 = *s1;</span><br><span class=\"line\">        min1 = HT[i].weight;</span><br><span class=\"line\">        *s1 = i;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        min2 = HT[i].weight;</span><br><span class=\"line\">        *s2 = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//两个结点和后续的所有未构建成树的结点做比较</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i<span class=\"number\">+1</span>; j &lt;= end; j++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果有父结点，直接跳过，进行下一个</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(HT[j].parent != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果比最小的还小，将min2=min1，min1赋值新的结点的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(HT[j].weight &lt; min1)&#123;</span><br><span class=\"line\">            min2 = min1;</span><br><span class=\"line\">            min1 = HT[j].weight;</span><br><span class=\"line\">            *s2 = *s1;</span><br><span class=\"line\">            *s1 = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果介于两者之间，min2赋值为新的结点的位置下标</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(HT[j].weight &gt;= min1 &amp;&amp; HT[j].weight &lt; min2)&#123;</span><br><span class=\"line\">            min2 = HT[j].weight;</span><br><span class=\"line\">            *s2 = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构建算法实现\"><a href=\"#构建算法实现\" class=\"headerlink\" title=\"构建算法实现\"></a>构建算法实现</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//HT为地址传递的存储哈夫曼树的数组，w为存储结点权重值的数组，n为结点个数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CreateHuffmanTree</span><span class=\"params\">(HuffmanTree *HT, <span class=\"type\">int</span> *w, <span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">1</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// 如果只有一个编码就相当于0</span></span><br><span class=\"line\">    <span class=\"type\">int</span> m = <span class=\"number\">2</span>*n<span class=\"number\">-1</span>; <span class=\"comment\">// 哈夫曼树总节点数，n就是叶子结点</span></span><br><span class=\"line\">    *HT = (HuffmanTree) <span class=\"built_in\">malloc</span>((m<span class=\"number\">+1</span>) * <span class=\"built_in\">sizeof</span>(HTNode)); <span class=\"comment\">// 0号位置不用</span></span><br><span class=\"line\">    HuffmanTree p = *HT;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化哈夫曼树中的所有结点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        (p+i)-&gt;weight = *(w+i<span class=\"number\">-1</span>);</span><br><span class=\"line\">        (p+i)-&gt;parent = <span class=\"number\">0</span>;</span><br><span class=\"line\">        (p+i)-&gt;left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        (p+i)-&gt;right = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//从树组的下标 n+1 开始初始化哈夫曼树中除叶子结点外的结点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = n<span class=\"number\">+1</span>; i &lt;= m; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        (p+i)-&gt;weight = <span class=\"number\">0</span>;</span><br><span class=\"line\">        (p+i)-&gt;parent = <span class=\"number\">0</span>;</span><br><span class=\"line\">        (p+i)-&gt;left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        (p+i)-&gt;right = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//构建哈夫曼树</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = n<span class=\"number\">+1</span>; i &lt;= m; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> s1, s2;</span><br><span class=\"line\">        <span class=\"built_in\">Select</span>(*HT, i<span class=\"number\">-1</span>, &amp;s1, &amp;s2);</span><br><span class=\"line\">        (*HT)[s1].parent = (*HT)[s2].parent = i;</span><br><span class=\"line\">        (*HT)[i].left = s1;</span><br><span class=\"line\">        (*HT)[i].right = s2;</span><br><span class=\"line\">        (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","text":"基本概念 路径:从树中一个结点到另一个结点之间的分支构成这两个结点间的路径。 结点的路径长度:两结点间路径上的分支数。 树的路径长度：从树根到每一个结点的路径长...","permalink":"/post/哈夫曼树","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":17,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">哈夫曼树构造算法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">哈夫曼算法代码实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%BC%97%E6%9B%BC%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">哈弗曼树中结点结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%BC%97%E6%9B%BC%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">哈弗曼树中的查找算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BA%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">构建算法实现</span></a></li></ol></li></ol>","author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"配置极光主题","uid":"a8b6b9bbf4052440f27a448efb8e5b47","slug":"极光主题配置","date":"2024-11-17T14:44:01.000Z","updated":"2024-11-17T15:09:08.459Z","comments":true,"path":"api/articles/极光主题配置.json","keywords":null,"cover":null,"text":"下载HEXO首先要先下载npm，在Node.js官网下载LTS版本到本地。下载好后，在命令行中输入： 1npm -v 来查看版本如果之前已经下载过了，但是版本落...","permalink":"/post/极光主题配置","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"配置","slug":"配置","count":2,"path":"api/tags/配置.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"配置QT","uid":"be74305dcdfd13488949087b92f952ec","slug":"配置QT","date":"2024-11-15T11:49:10.000Z","updated":"2024-11-17T14:41:36.115Z","comments":true,"path":"api/articles/配置QT.json","keywords":null,"cover":null,"text":"刚刚成功在QT上配置了安卓开发系统，顺便写一个教程吧。 开发环境配置安卓系统开发需要三个东西：JDK，SDK，NDK。首先JDK直接从官网下下来就可以了，下载好...","permalink":"/post/配置QT","photos":[],"count_time":{"symbolsCount":724,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"配置","slug":"配置","count":2,"path":"api/tags/配置.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}