{"title":"并查集","uid":"c18469ab20e7b093d36b4a61728d07eb","slug":"并查集","date":"2024-10-26T15:03:22.000Z","updated":"2024-10-26T15:35:07.973Z","comments":true,"path":"api/articles/并查集.json","keywords":null,"cover":null,"content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>并查集可以用来干什么的：<br>将两个集合合并<br>询问两个元素是否在一个集合中<br>暴力做法：<br>belong[x]&#x3D;a表示x在集合a中，但是合并的操作很难<br>近乎O(1)的时间复杂度内完成两个操作<br>基本原理：每个节点用一个树来表示，树根的编号就是整个集合的编号<br>每个节点存储它的父节点<br>用p[x]表示x节点的父节点，如果p[x]&#x3D;&#x3D;x表示树根<br>如何求x的集合编号：一路往上找，直到树根：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(p[x]!=x)x=p[x];</span><br></pre></td></tr></table></figure>\n<p>如何合并两个集合：把集合2的p[]设成集合1树根：<br>p[2_root]&#x3D;1_root;<br>优化：<br>假设集合树有一个路径A-&gt;B-&gt;C-&gt;Root<br>注意到A，B，C都是Root的集合，如果我们要查询A，需要x&#x3D;p[x]多次，我们可以直接设置p[A,B,C]&#x3D;Root<br>优化：路径压缩</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">10010</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> p[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x!=p[x])p[x]=<span class=\"built_in\">find</span>(p[x]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)p[i]=i;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> op[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s%d%d&quot;</span>,*op,&amp;a,&amp;b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;I&#x27;</span>)p[<span class=\"built_in\">find</span>(x)]=<span class=\"built_in\">find</span>(b);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;Q&#x27;</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">find</span>(a)==<span class=\"built_in\">find</span>(b))<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","text":"简介并查集可以用来干什么的：将两个集合合并询问两个元素是否在一个集合中暴力做法：belong[x]=a表示x在集合a中，但是合并的操作很难近乎O(1)的时间复杂...","permalink":"/post/并查集","photos":[],"count_time":{"symbolsCount":938,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":15,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li></ol>","author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"算法目录","uid":"e89c78349414451d23c7b39518c39b85","slug":"目录","date":"2024-10-27T07:58:16.000Z","updated":"2024-10-27T08:04:38.256Z","comments":true,"path":"api/articles/目录.json","keywords":null,"cover":null,"text":"贪心 区间问题 Huffman树 排序不等式 绝对值不等式 堆公式 动态规划 背包问题 线性DP 区间DP 计数类DP 数位统计DP 状态压缩DP 树形DP 记...","permalink":"/post/目录","photos":[],"count_time":{"symbolsCount":246,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":15,"path":"api/tags/算法.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"单调队列","uid":"0b051914180f3217ee5468b2e6dfab33","slug":"滑动窗口","date":"2024-10-22T11:49:10.000Z","updated":"2024-10-24T09:22:02.562Z","comments":true,"path":"api/articles/滑动窗口.json","keywords":null,"cover":null,"text":"入门有一个大小为k的滑动窗口，它从数组的的最左边移动到最右边只能在窗口中看到k个数字，每次滑动窗口有向右移动一个位置。确定对于滑动窗口的每个位置，输出窗口的最大...","permalink":"/post/滑动窗口","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":15,"path":"api/tags/算法.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}