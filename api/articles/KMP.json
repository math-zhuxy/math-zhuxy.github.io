{"title":"KMP","uid":"53896b079468d4c41963b2300dea196e","slug":"KMP","date":"2024-10-14T02:54:06.000Z","updated":"2024-10-16T00:10:57.285Z","comments":true,"path":"api/articles/KMP.json","keywords":null,"cover":[],"content":"<h2 id=\"KMP简介\"><a href=\"#KMP简介\" class=\"headerlink\" title=\"KMP简介\"></a>KMP简介</h2><p>假设有两个字符串需要匹配，此时已经匹配到i，j位置：<br>母串：str1 … str1 a(i) …<br>字串：str1 (j’) … str1 b(j) …</p>\n<p>发现index位置a与b不相等，此时字串的匹配指针j不需要重新移到开始，i指针也不需要移动，j指针只要移动到j’位置即可</p>\n<p>因此我们只需要找到最长前后缀即可：<br>以str&#x3D;”abcdefabc”为例</p>\n<p>注意：为了方便表示，我们让字符串下标从1开始</p>\n<h2 id=\"ne数组\"><a href=\"#ne数组\" class=\"headerlink\" title=\"ne数组\"></a>ne数组</h2><p>Next[i]&#x3D;j表示:<br>str[1,j]&#x3D;str[i-j+1,i]<br>以下图为例：<br><img src=\"/../figure/kmp_fig.png\" alt=\"KMP\"><br>Next[i]的方法：<br>对于母串STR和字串str，假如母串从x<del>i-1 ,子串从1</del>j都是匹配的，此时匹配下一个位置：<br>如果STR[i]&#x3D;&#x3D;str[j+1]，则i和j继续向后移动一位<br>如果STR[i]!&#x3D;str[j+1]:<br>注意到对于str来说，1到Next[j]段等于…到j段，而子串和母串的STR[…,i-1]与str[1,j]是相等的<br>同时，根据Next数组定义：str[1,Next[j]]与str[…,j]是相等的，因此：STR[…,i-1]与str[1,Next[j]]部分是相等的，因此j指针可以移动到Next[j]，让i与Next[j]+1匹配<br>因此i指针不用动，j指针可以退回到Next[j]<br>以下图为例：<br><img src=\"/../figure/kmp_move.png\" alt=\"KMP_MOVE\"><br>匹配过程的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//i从1开始遍历母串所有的字符，j从0开始(因为STR[i]与str[j+1]匹配的)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>; i &lt;= m; i ++)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果s[i]与s[j+1]不匹配，一直移动到无前后缀相等或者匹配为止</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &amp;&amp; s[i] != s[j<span class=\"number\">+1</span>])j=Next[j];</span><br><span class=\"line\">    <span class=\"comment\">//如果是匹配成功的情况，j和i可以往下一位走了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s[i] == s[j<span class=\"number\">+1</span>])j++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j == n)<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ok&quot;</span>);<span class=\"comment\">//已经移动到子串的末尾了，匹配成功</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来即是如何求解Next[i]:<br>Next[i]的求解过程其实和字符串的匹配过程很相似<br>首先Next[1]&#x3D;0，第一个字母匹配失败了，只能从0开始了。<br>对于每个i假如str[i]与str[j+1]不匹配，即前后缀不等，那么j往前移动到Next[j]处继续匹配。<br>其实就是自己和自己匹配的过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>, j = <span class=\"number\">0</span>; i &lt;= m; i ++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &amp;&amp; s[i] != s[j<span class=\"number\">+1</span>])j=Next[j];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s[i] == s[j<span class=\"number\">+1</span>])j++;</span><br><span class=\"line\">    <span class=\"comment\">//将最后的结果存入Next[i]中</span></span><br><span class=\"line\">    Next[i]=j;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"题目及解答\"><a href=\"#题目及解答\" class=\"headerlink\" title=\"题目及解答\"></a>题目及解答</h1><p>给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉数字。</p>\n<p>模式串 P在字符串 S中多次作为子串出现。</p>\n<p>求出模式串 P在字符串 S中所有出现的位置的起始下标。<br>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n, m;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">100010</span>, M = <span class=\"number\">1000010</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> p[N], s[M];</span><br><span class=\"line\"><span class=\"type\">int</span> ne[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin &gt;&gt; n &gt;&gt; p + <span class=\"number\">1</span> &gt;&gt; m &gt;&gt; s + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>, j = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (j &amp;&amp; p[i] != p[j + <span class=\"number\">1</span>])j = ne[j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p[i] == p[j + <span class=\"number\">1</span>])j++;</span><br><span class=\"line\">\t\tne[i] = j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (j &amp;&amp; s[i] != p[j + <span class=\"number\">1</span>])j = ne[j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] == p[j + <span class=\"number\">1</span>])j++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j == n)&#123;</span><br><span class=\"line\">\t\t    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, i - n);</span><br><span class=\"line\">\t\t    j=ne[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><p>其实next数组还是可以进一步优化，举个例子：假设字符a的下标为i，其next值为next[i]，假设str[i]&#x3D;&#x3D;str[next[i]]，则不妨发现：当str在j+1处的与STR不的i处匹配，则str的j将跳到next[j]处，但此时next[j]与j处是相等的，因此这个匹配其实是没有必要的，可以直接移到next[next[i]]处，如此循环。我们用nextval数组储存这个最终的移动结果，表示：如果j处不匹配，则直接移动到nextval[j]处。<br>求nextval方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//如果相等，直接移动到next[i]的nextval处。</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(str[i]==str[next[i]])nextval[i]=nextval[next[i]];</span><br><span class=\"line\">\t<span class=\"comment\">//如果不相等，不需要多次移</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> nextval[i]=next[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","text":"KMP简介假设有两个字符串需要匹配，此时已经匹配到i，j位置：母串：str1 … str1 a(i) …字串：str1 (j’) … str1 b(j) … 发...","permalink":"/post/KMP","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":19,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KMP%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">KMP简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ne%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">ne数组</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%8F%8A%E8%A7%A3%E7%AD%94\"><span class=\"toc-text\">题目及解答</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">优化</span></a>","author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"DP","uid":"25ed3aa3446c2c64cf6228f9f4e4f9c4","slug":"DP","date":"2024-10-15T10:12:39.000Z","updated":"2024-11-18T03:49:57.655Z","comments":true,"path":"api/articles/DP.json","keywords":null,"cover":null,"text":"简介DP是一个非常广泛的题目类型。比较难的DP题目一般都很抽象，很难提取出DP数组出来，这边文章也只是笼统的介绍一下DP，并介绍一个DP最经典最简单的例子。定义...","permalink":"/post/DP","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":19,"path":"api/tags/算法.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DFS","uid":"cdfc7cbbb7cbed062094116ffd80f917","slug":"DFS","date":"2024-10-12T04:56:45.000Z","updated":"2024-10-19T13:42:40.023Z","comments":true,"path":"api/articles/DFS.json","keywords":null,"cover":[],"text":"DFS简介DFS通常指的是深度优先搜索（Depth-First Search），它是一种用于遍历或搜索树或图的算法。在树中，DFS从根开始（选择某些节点作为根，...","permalink":"/post/DFS","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":19,"path":"api/tags/算法.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}