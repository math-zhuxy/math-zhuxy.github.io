{"title":"KMP","uid":"53896b079468d4c41963b2300dea196e","slug":"KMP","date":"2024-10-14T02:54:06.000Z","updated":"2024-10-14T11:07:48.137Z","comments":true,"path":"api/articles/KMP.json","keywords":null,"cover":[],"content":"<h2 id=\"KMP简介\"><a href=\"#KMP简介\" class=\"headerlink\" title=\"KMP简介\"></a>KMP简介</h2><p>假设有两个字符串需要匹配，此时已经匹配到i，j位置：<br>母串：str1 … str1 a(i) …<br>字串：str1 (j’) … str1 b(j) …</p>\n<p>发现index位置a与b不相等，此时字串的匹配指针j不需要重新移到开始，i指针也不需要移动，j指针只要移动到j’位置即可</p>\n<p>因此我们只需要找到最长前后缀即可：<br>以str&#x3D;”abcdefabc”为例</p>\n<p>注意：为了方便表示，我们让字符串下标从1开始</p>\n<h2 id=\"ne数组\"><a href=\"#ne数组\" class=\"headerlink\" title=\"ne数组\"></a>ne数组</h2><p>Next[i]&#x3D;j表示:<br>str[1,j]&#x3D;str[i-j+1,i]<br>以下图为例：<br><img src=\"/../figure/kmp_fig.png\" alt=\"KMP\"><br>Next[i]的方法：<br>对于母串STR和字串str，假如母串从x<del>i-1，字串从1</del>j都是匹配的，此时匹配下一个位置：<br>如果STR[i]&#x3D;&#x3D;str[j+1]，则i和j继续向后移动一位<br>如果STR[i]!&#x3D;str[j+1]:<br>注意到对于str来说，1到Next[j]段等于…到j段，<br>因此i指针不用动，j指针可以退回到Next[j]<br>以下图为例：<br><img src=\"/../figure/kmp_move.png\" alt=\"KMP_MOVE\"></p>\n","feature":true,"text":"KMP简介假设有两个字符串需要匹配，此时已经匹配到i，j位置：母串：str1 … str1 a(i) …字串：str1 (j’) … str1 b(j) … 发...","permalink":"/post/KMP","photos":[],"count_time":{"symbolsCount":437,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KMP%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">KMP简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ne%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">ne数组</span></a></li></ol>","author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"DFS","uid":"cdfc7cbbb7cbed062094116ffd80f917","slug":"DFS","date":"2024-10-12T04:56:45.000Z","updated":"2024-10-13T10:58:48.213Z","comments":true,"path":"api/articles/DFS.json","keywords":null,"cover":[],"text":"DFS简介DFS属于一种树的遍历方式。基本框架如下： 1234567891011121314151617#include<iostream>using name...","permalink":"/post/DFS","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}