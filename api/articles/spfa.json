{"title":"spfa","uid":"b15a3d80cccdf73982f5b8a5b568cf91","slug":"spfa","date":"2024-10-17T08:22:06.000Z","updated":"2024-10-18T10:05:15.879Z","comments":true,"path":"api/articles/spfa.json","keywords":null,"cover":null,"content":"<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><p>SPFA算法仅仅只是Bellman_ford算法的一个优化。<br>Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</p>\n<h1 id=\"值得注意的是\"><a href=\"#值得注意的是\" class=\"headerlink\" title=\"值得注意的是\"></a>值得注意的是</h1><ol>\n<li><p>st数组的作用：判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。<br>即便不使用st数组最终也没有什么关系，但是使用的好处在于可以提升效率。</p>\n</li>\n<li><p>SPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的:</p>\n<ol>\n<li>Dijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就不可逆了(不可标记为true后改变为false)；SPFA算法中的st数组仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。</li>\n<li>Dijkstra算法里使用的是优先队列保存的是当前未确定最小距离的点，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是记录一下当前发生过更新的点。</li>\n<li>Bellman_ford算法里最后return-1的判断条件写的是dist[n]&gt;0x3f3f3f3f&#x2F;2;而spfa算法写的是dist[n]&#x3D;&#x3D;0x3f3f3f3f;其原因在于Bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是SPFA算法不一样，它相当于采用了BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。</li>\n<li>Bellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是SPFA算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环。</li>\n<li>由于SPFA算法是由Bellman_ford算法优化而来，在最坏的情况下时间复杂度和它一样即时间复杂度为 $O(nm)$</li>\n</ol>\n</li>\n</ol>\n<p> ，假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。(好像SPFA有点小小万能的感觉?)。<br>    6) 求负环一般使用SPFA算法，方法是用一个cnt数组记录每个点到源点的边数，一个点被更新一次就+1，一旦有点的边数达到了n那就证明存在了负环。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">1e5</span><span class=\"number\">+10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> fi first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> se second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; PII;<span class=\"comment\">//到源点的距离，下标号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> h[N],e[N],w[N],ne[N],idx=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> dist[N];<span class=\"comment\">//各点到源点的距离</span></span><br><span class=\"line\"><span class=\"type\">bool</span> st[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    e[idx]=b;w[idx]=c;ne[idx]=h[a];h[a]=idx++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">spfa</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    queue&lt;PII&gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    st[<span class=\"number\">1</span>]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(q.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">        PII p=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> t=p.se;</span><br><span class=\"line\">        st[t]=<span class=\"literal\">false</span>;<span class=\"comment\">//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=h[t];i!=<span class=\"number\">-1</span>;i=ne[i])&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> j=e[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dist[j]&gt;dist[t]+w[i])&#123;</span><br><span class=\"line\">                dist[j]=dist[t]+w[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!st[j])&#123;<span class=\"comment\">//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率</span></span><br><span class=\"line\">                    st[j]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(&#123;dist[j],j&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dist[n]==<span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b,c;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(a,b,c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"built_in\">spfa</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(res==<span class=\"number\">-1</span>) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;impossible&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,res);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","text":"分析SPFA算法仅仅只是Bellman_ford算法的一个优化。Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那...","permalink":"/post/spfa","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":19,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF\"><span class=\"toc-text\">值得注意的是</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">代码</span></a></li></ol>","author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"单链表","uid":"599e3a777e3c1f587525e8b550969355","slug":"单链表","date":"2024-10-20T12:24:58.000Z","updated":"2024-12-21T10:18:02.896Z","comments":true,"path":"api/articles/单链表.json","keywords":null,"cover":null,"text":"这是一种用数组模拟链表的方法，因为在C++中new方法需要的时间较久，因此需要使用一种方式通过下标来快速的实现链表的操作。有几个关键的值和数组：head表示头节...","permalink":"/post/单链表","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":19,"path":"api/tags/算法.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"朴素Dijkstra","uid":"ad369abec5fbd335002625b880bbf6b7","slug":"朴素Dijkstra","date":"2024-10-17T08:21:57.000Z","updated":"2024-12-04T01:35:53.054Z","comments":true,"path":"api/articles/朴素Dijkstra.json","keywords":null,"cover":[],"text":"介绍迪杰斯特拉算法采用的是一种贪心的策略。 求源点到其余各点的最短距离步骤如下： 用一个 dist 数组保存源点到其余各个节点的距离，dist[i] 表示源点到...","permalink":"/post/朴素Dijkstra","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":19,"path":"api/tags/算法.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}