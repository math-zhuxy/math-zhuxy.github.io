{"title":"MST","uid":"ac69b4c1992072269abea91444d26b98","slug":"MST","date":"2024-11-21T01:56:04.000Z","updated":"2024-11-21T08:21:55.038Z","comments":true,"path":"api/articles/MST.json","keywords":null,"cover":null,"content":"<h1 id=\"MST定义\"><a href=\"#MST定义\" class=\"headerlink\" title=\"MST定义\"></a>MST定义</h1><p>设 $G&#x3D;(V,E)$ 是一个无向连通图，$E$ 中的每个权值 $c(u,v)$ ，称为 $(u,v)$ 的边长。<br>图 $G$ 的生成树( $n-1$ 条边和 $n$ 个顶点)上各边的权值之和称为该生成树的代价。</p>\n<h1 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>适合<strong>稠密网</strong></p>\n<ol>\n<li>在连通网的顶点集合V中，任选一个顶点，构成最小生成树的初始顶点集合U;</li>\n<li>在U和V-U中各选一个顶点，使得该边的权值最小，把该边加入到最小生成树的边集TE中，同时将V-U中的该顶点并入到U中;</li>\n<li>反复执行第 2 步，直至V-U&#x3D;Ø为止。</li>\n</ol>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>设置一个辅助数组closedge[]，用来保存生成树外顶点（V-U）中各顶点到生成树U中顶点具有权值最小的边。</p>\n<ul>\n<li>lowcost 域：该边的权值；</li>\n<li>adjvex 域：边依附于 U 中的顶点，-1表示已加入生成树的顶点集合<br>closedge[j].adjvex&#x3D;k，表明边 $(v_j, v_k)$ 是V-U中顶点 $v_j$ 到U中权值最小的边，而顶点 $v_k$ 是该边所依附的U中的顶点。 closedge[j].lowcost存放该边的权值。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Prim</span> <span class=\"params\">( MGraph G, MST&amp; T, <span class=\"type\">int</span> u )</span></span>&#123; <span class=\"comment\">//图以邻接矩阵存储</span></span><br><span class=\"line\">    <span class=\"type\">float</span> lowcost [];</span><br><span class=\"line\">    <span class=\"type\">int</span> adjvex [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; vexnum; i++ ) &#123;</span><br><span class=\"line\">        lowcost[i] = G.arcs[u][i]; <span class=\"comment\">//Vu到各点代价</span></span><br><span class=\"line\">        adjvex[i] = u; <span class=\"comment\">//及最短带权路径</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    adjvex[u] = <span class=\"number\">-1</span>; <span class=\"comment\">//加到生成树顶点集合</span></span><br><span class=\"line\">    <span class=\"type\">int</span> k = <span class=\"number\">0</span>; <span class=\"comment\">//存放最小生成树结点的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; G.n; i++ )&#123; <span class=\"comment\">//循环n-1次, 加入n-1条边</span></span><br><span class=\"line\">        EdgeData min = MaxValue; <span class=\"type\">int</span> v = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//找到权值最小的边</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; vexnum; j++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( adjvex[j] != <span class=\"number\">-1</span> &amp;&amp; <span class=\"comment\">// =-1不参选</span></span><br><span class=\"line\">            lowcost[j] &lt; min )&#123;</span><br><span class=\"line\">                v = j;</span><br><span class=\"line\">                min = lowcost[j]; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( v ) &#123; <span class=\"comment\">//v=0表示再也找不到要求顶点</span></span><br><span class=\"line\">            <span class=\"comment\">//加入生成树</span></span><br><span class=\"line\">            T[k].tail = adjvex[v]; </span><br><span class=\"line\">            T[k].head = v;</span><br><span class=\"line\">            T[k++].cost = lowcost[v]; </span><br><span class=\"line\">            adjvex[v] = <span class=\"number\">-1</span>; <span class=\"comment\">//该边加入生成树标记</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为U增肌了一个v顶点，因此要更新lowcost[]和adjvex数组</span></span><br><span class=\"line\">            <span class=\"comment\">// 遍历 V-U 中的顶点，看看有没有顶点adjvex可以更新</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j &lt; G.n; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( adjvex[j] != <span class=\"number\">-1</span> &amp;&amp; G.arcs[v][j] &lt; lowcost[j] ) &#123; </span><br><span class=\"line\">                    lowcost[j] = G.arcs[v][j]; </span><br><span class=\"line\">                    adjvex[j] = v;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h1><p>适合<strong>稀疏网</strong></p>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>图的连通分量（Connected Component）是指无向图中的一个子图，在这个子图中任意两个顶点之间都存在路径直接或间接地连接它们，并且这个子图不能通过添加更多的边或顶点而保持这一性质。换句话说，连通分量是一个最大的无向图子集，其中任何两个节点都是互相可达的。<br>设有一个有 n 个顶点的连通网络 N &#x3D; { V, E },最初先构造一个只有 n 个顶点，没有边的非连通图 T &#x3D; { V, Æ }, 图中每个顶点自成一个连通分量。当在 E 中选到一条具有最小权值的边时,若该边的两个顶点落在不同的连通分量上，则将此边加入到 T 中；否则将此边舍去，重新选择一条权值最小的边。如此重复下去，直到所有顶点在同一个连通分量上为止。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">U=V,TE=&#123;&#125;,visited=[]</span><br><span class=\"line\">while T连通分量个数!=1:</span><br><span class=\"line\">    (u,v):E中的最短边，且visited[(u,v)]=false</span><br><span class=\"line\">    if u,v 位于 T 的两个不同连通分量:</span><br><span class=\"line\">        将 (i,v)并入TE</span><br><span class=\"line\">        将两个连通分量合并为一个连通分量</span><br><span class=\"line\">    visited[(u,v)]=true</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>定义一个一维数组Vset[n] ，存放图T中每个顶点所在的连通分量的编号。</p>\n<ol>\n<li>初值：Vset[i]&#x3D;i，表示每个顶点各自组成一个连通分量，连通分量的编号简单地使用顶点在图中的位置(编号)。</li>\n<li>当往T中增加一条边(vi，vj) 时，先检查Vset[i]和Vset[j]值：<ul>\n<li>若Vset[i]&#x3D;Vset[j]：表明vi和vj处在同一个连通分量中，加入此边会形成回路</li>\n<li>若Vset[i]≠Vset[j]，则加入此边不会形成回路，将此边加入到生成树的边集中。<br>加入一条新边后，将两个不同的连通分量合并：将一个连通分量的编号换成另一个连通分量的编号</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MSTEdge *<span class=\"title\">Kruskal_MST</span><span class=\"params\">(ELGraph *G)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/* 图G用边表进行存储*/</span></span><br><span class=\"line\">    MSTEdge TE[ ] ; </span><br><span class=\"line\">    <span class=\"type\">int</span> j, k, v, s1, s2, Vset[ ] ;</span><br><span class=\"line\">    WeightType w ;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j=<span class=\"number\">0</span>; j&lt;G-&gt;vexnum; j++)Vset[j]=j ; <span class=\"comment\">/* 初始化数组Vset[n] */</span></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(G-&gt;edgelist) ; <span class=\"comment\">/* 对表按权值从小到大排序 */</span></span><br><span class=\"line\">    j=<span class=\"number\">0</span> ; k=<span class=\"number\">0</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k&lt;G-&gt;vexnum<span class=\"number\">-1</span>&amp;&amp;j&lt; G-&gt;edgenum)&#123; </span><br><span class=\"line\">        s1=Vset[G-&gt;edgelist[j].vex1] ;</span><br><span class=\"line\">        s2=Vset[G-&gt;edgelist[j].vex2] ;</span><br><span class=\"line\">        <span class=\"comment\">/* 若边的两个顶点的连通分量编号不同, 边加入到TE中 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1!=s2)&#123; </span><br><span class=\"line\">            TE[k].vex1=G-&gt;edgelist[j].vex1 ;</span><br><span class=\"line\">            TE[k].vex2=G-&gt;edgelist[j].vex2 ;</span><br><span class=\"line\">            TE[k].weight=G-&gt;edgelist[j].weight ; </span><br><span class=\"line\">            k++ ;</span><br><span class=\"line\">            <span class=\"comment\">/*合并连通分量：将s2与s1合并（低配版并查集） */</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(v=<span class=\"number\">0</span>; v&lt;G-&gt;vexnum; v++)<span class=\"keyword\">if</span>(Vset[v]==s2)Vset[v]=s1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(Vset) ; </span><br><span class=\"line\">    <span class=\"keyword\">return</span>(TE) ;</span><br><span class=\"line\">&#125; <span class=\"comment\">/* 求最小生成树的Kruskal算法 */</span></span><br></pre></td></tr></table></figure>","feature":true,"text":"MST定义设 $G=(V,E)$ 是一个无向连通图，$E$ 中的每个权值 $c(u,v)$ ，称为 $(u,v)$ 的边长。图 $G$ 的生成树( $n-1$ ...","permalink":"/post/MST","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":15,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MST%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">MST定义</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Prim%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Prim算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">代码</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Kruskal%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Kruskal算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-1\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81-1\"><span class=\"toc-text\">代码</span></a></li></ol></li></ol>","author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"常见模板","uid":"5eedc39c4343d9a40153c05972544dcd","slug":"常见模板","date":"2024-11-21T08:24:29.000Z","updated":"2024-11-23T11:21:50.741Z","comments":true,"path":"api/articles/常见模板.json","keywords":null,"cover":null,"text":"并查集123456const int N = 10010;int p[N];int find(int x){ if(x!=p[x])p[x]=find(p[x]...","permalink":"/post/常见模板","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":15,"path":"api/tags/算法.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"PowerInfer论文","uid":"1150f8d04ea2174e83f737731d4cd296","slug":"powerinfer论文","date":"2024-11-19T12:30:31.000Z","updated":"2024-11-25T11:25:30.727Z","comments":true,"path":"api/articles/powerinfer论文.json","keywords":null,"cover":[],"text":"论文原文链接论文github链接 论文结构1. 引言 讨论了当前大语言模型的推理需求与挑战，尤其是在消费级GPU上运行模型的难点： 大语言模型的内存需求巨大，远...","permalink":"/post/powerinfer论文","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"论文阅读","slug":"论文阅读","count":1,"path":"api/tags/论文阅读.json"}],"author":{"name":"Math-zhuxy","slug":"blog-author","avatar":"https://sse-market-source-1320172928.cos.ap-guangzhou.myqcloud.com/src/images/uploads/1728918801765528128_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241014222719.jpg","link":"/","description":"Blood of the First Men, drawn by the sword.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}